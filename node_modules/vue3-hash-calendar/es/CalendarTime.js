import { createVNode as _createVNode } from "vue";
import { defineComponent, nextTick, reactive, ref, watch } from "vue";
import { useRect } from "./hooks";
import { checkPlatform, fillNumber, makeDateProp, makeNumberProp } from "./utils";
const calendarTimeProps = {
  show: Boolean,
  defaultTime: makeDateProp(new Date()),
  disabledTime: {
    type: Function,
    default: () => false
  },
  minuteStep: makeNumberProp(1),
  calendarDate: {
    type: Object,
    default: () => ({})
  }
};
var stdin_default = defineComponent({
  name: "CalendarTime",
  props: calendarTimeProps,
  emits: ["change"],
  setup(props, {
    emit
  }) {
    const timeContentRef = reactive([]);
    const timeItemRef = reactive([]);
    const checkedDate = ref({
      hours: new Date().getHours(),
      minutes: new Date().getMinutes()
    });
    const timeHeight = ref(0);
    const timeArray = ref([]);
    const timeStartY = ref(0);
    const timeStartUp = ref(0);
    const initTimeArray = () => {
      const hours = [];
      timeArray.value = [];
      for (let i = 0; i < 24; i++) {
        hours.push(i);
      }
      const minutes = [];
      for (let i = 0; i < 60; i++) {
        if (i % props.minuteStep === 0) {
          minutes.push(i);
        }
      }
      timeArray.value.push(hours, minutes);
      nextTick(() => {
        const checkHours = checkedDate.value.hours;
        const checkMinutes = checkedDate.value.minutes;
        timeHeight.value = useRect(timeItemRef[0]).height;
        const [timeContentFirst, timeContentSecond] = timeContentRef;
        const hoursUp = (2 - checkHours) * timeHeight.value;
        if (timeContentFirst) {
          timeContentFirst.style.transform = "translate3d(0px," + hoursUp + "px,0px)";
        }
        const minutesUp = (2 - checkMinutes / props.minuteStep) * timeHeight.value;
        if (timeContentSecond) {
          timeContentSecond.style.transform = "translate3d(0px," + minutesUp + "px,0px)";
        }
      });
    };
    const formatDisabledDate = (time, index) => {
      const hours = index === 0 ? time : checkedDate.value.hours;
      const minutes = index === 1 ? time : checkedDate.value.minutes;
      const dateStr = `${props.calendarDate.year}/${props.calendarDate.month + 1}/${props.calendarDate.day} ${hours}:${minutes}`;
      const fDate = new Date(dateStr);
      return props.disabledTime(fDate);
    };
    const timeTouchStart = (e) => {
      if (e.cancelable)
        e.preventDefault();
      timeStartY.value = e.changedTouches[0].pageY;
      const {
        transform
      } = e.currentTarget.style;
      if (transform) {
        timeStartUp.value = parseFloat(transform.split(" ")[1].split("px")[0]);
      }
    };
    const timeTouchEnd = (e, index) => {
      const {
        transform
      } = e.currentTarget.style;
      let endUp = timeStartUp.value;
      if (transform) {
        endUp = parseFloat(e.currentTarget.style.transform.split(" ")[1].split("px")[0]);
      }
      const distance = Math.abs(endUp - timeStartUp.value);
      const upCount = Math.floor(distance / timeHeight.value) || 1;
      const halfWinWith = timeHeight.value / 2;
      let up = timeStartUp.value;
      if (endUp <= timeStartUp.value) {
        if (distance <= halfWinWith) {
          up = timeStartUp.value;
        } else {
          up = timeStartUp.value - timeHeight.value * upCount;
          if (up < -(timeArray.value[index].length - 3) * timeHeight.value) {
            up = -(timeArray.value[index].length - 3) * timeHeight.value;
          }
        }
      } else if (distance <= halfWinWith) {
        up = timeStartUp.value;
      } else {
        up = timeStartUp.value + timeHeight.value * upCount;
        if (up > timeHeight.value * 2) {
          up = timeHeight.value * 2;
        }
      }
      if (index === 0) {
        const hour = 2 - Math.round(up / timeHeight.value);
        if (formatDisabledDate(hour, index)) {
          up = timeStartUp.value;
        } else {
          checkedDate.value.hours = hour;
        }
      } else {
        const minute = 2 - Math.round(up / timeHeight.value);
        if (formatDisabledDate(minute, index)) {
          up = timeStartUp.value;
        } else {
          checkedDate.value.minutes = minute * props.minuteStep;
        }
      }
      e.currentTarget.style.webkitTransition = "transform 300ms";
      e.currentTarget.style.transform = "translate3d(0px," + up + "px,0px)";
    };
    const timeTouchMove = (e, index) => {
      const moveEndY = e.changedTouches[0].pageY;
      const Y = moveEndY - timeStartY.value;
      e.currentTarget.style.transform = "translate3d(0px," + (Y + timeStartUp.value) + "px,0px)";
      if (checkPlatform() === "2") {
        timeTouchEnd(e, index);
        return false;
      }
    };
    const isBeSelectedTime = (time, index) => index === 0 && time === checkedDate.value.hours || index === 1 && time === checkedDate.value.minutes;
    watch(() => props.defaultTime, (val) => {
      if (!(val instanceof Date)) {
        throw new Error("The calendar component's defaultTime must be date type!");
      }
      checkedDate.value.hours = val.getHours();
      checkedDate.value.minutes = val.getMinutes();
    }, {
      immediate: true
    });
    watch(checkedDate, (val) => {
      emit("change", val);
    }, {
      deep: true,
      immediate: true
    });
    watch(() => props.show, (val) => {
      if (val) {
        setTimeout(() => {
          initTimeArray();
        }, 100);
      }
    }, {
      immediate: true
    });
    watch(() => props.minuteStep, (val) => {
      if (val <= 0 || val >= 60) {
        throw new Error(`The minutes-step can't be: ${val}!`);
      }
      if (60 % val !== 0) {
        throw new Error("The minutes-step must be divided by 60!");
      }
    }, {
      immediate: true
    });
    const renderTimeItem = (time, index) => time.map((item, j) => _createVNode("div", {
      "ref": (ref2) => {
        timeItemRef.length = 0;
        timeItemRef.push(ref2);
      },
      "class": `time_item ${isBeSelectedTime(item, index) ? "time_item_show" : ""} ${formatDisabledDate(item, index) ? "time-disabled" : ""}`,
      "key": index + j
    }, [fillNumber(item)]));
    const renderCalendarTime = () => _createVNode("div", {
      "class": "time_body",
      "style": {
        display: props.show ? "flex" : "none"
      }
    }, [_createVNode("div", {
      "class": "time_group"
    }, [timeArray.value.map((item, index) => _createVNode("div", {
      "class": "time_content",
      "ref": (ref2) => {
        timeContentRef.push(ref2);
      },
      "key": index,
      "onTouchstart": timeTouchStart,
      "onTouchmove": (e) => timeTouchMove(e, index),
      "onTouchend": (e) => timeTouchEnd(e, index)
    }, [renderTimeItem(item, index)]))])]);
    return () => renderCalendarTime();
  }
});
export {
  calendarTimeProps,
  stdin_default as default
};
