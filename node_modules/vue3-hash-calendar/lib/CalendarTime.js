var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var stdin_exports = {};
__export(stdin_exports, {
  calendarTimeProps: () => calendarTimeProps,
  default: () => stdin_default
});
module.exports = __toCommonJS(stdin_exports);
var import_vue = require("vue");
var import_vue2 = require("vue");
var import_hooks = require("./hooks");
var import_utils = require("./utils");
const calendarTimeProps = {
  show: Boolean,
  defaultTime: (0, import_utils.makeDateProp)(new Date()),
  disabledTime: {
    type: Function,
    default: () => false
  },
  minuteStep: (0, import_utils.makeNumberProp)(1),
  calendarDate: {
    type: Object,
    default: () => ({})
  }
};
var stdin_default = (0, import_vue2.defineComponent)({
  name: "CalendarTime",
  props: calendarTimeProps,
  emits: ["change"],
  setup(props, {
    emit
  }) {
    const timeContentRef = (0, import_vue2.reactive)([]);
    const timeItemRef = (0, import_vue2.reactive)([]);
    const checkedDate = (0, import_vue2.ref)({
      hours: new Date().getHours(),
      minutes: new Date().getMinutes()
    });
    const timeHeight = (0, import_vue2.ref)(0);
    const timeArray = (0, import_vue2.ref)([]);
    const timeStartY = (0, import_vue2.ref)(0);
    const timeStartUp = (0, import_vue2.ref)(0);
    const initTimeArray = () => {
      const hours = [];
      timeArray.value = [];
      for (let i = 0; i < 24; i++) {
        hours.push(i);
      }
      const minutes = [];
      for (let i = 0; i < 60; i++) {
        if (i % props.minuteStep === 0) {
          minutes.push(i);
        }
      }
      timeArray.value.push(hours, minutes);
      (0, import_vue2.nextTick)(() => {
        const checkHours = checkedDate.value.hours;
        const checkMinutes = checkedDate.value.minutes;
        timeHeight.value = (0, import_hooks.useRect)(timeItemRef[0]).height;
        const [timeContentFirst, timeContentSecond] = timeContentRef;
        const hoursUp = (2 - checkHours) * timeHeight.value;
        if (timeContentFirst) {
          timeContentFirst.style.transform = "translate3d(0px," + hoursUp + "px,0px)";
        }
        const minutesUp = (2 - checkMinutes / props.minuteStep) * timeHeight.value;
        if (timeContentSecond) {
          timeContentSecond.style.transform = "translate3d(0px," + minutesUp + "px,0px)";
        }
      });
    };
    const formatDisabledDate = (time, index) => {
      const hours = index === 0 ? time : checkedDate.value.hours;
      const minutes = index === 1 ? time : checkedDate.value.minutes;
      const dateStr = `${props.calendarDate.year}/${props.calendarDate.month + 1}/${props.calendarDate.day} ${hours}:${minutes}`;
      const fDate = new Date(dateStr);
      return props.disabledTime(fDate);
    };
    const timeTouchStart = (e) => {
      if (e.cancelable)
        e.preventDefault();
      timeStartY.value = e.changedTouches[0].pageY;
      const {
        transform
      } = e.currentTarget.style;
      if (transform) {
        timeStartUp.value = parseFloat(transform.split(" ")[1].split("px")[0]);
      }
    };
    const timeTouchEnd = (e, index) => {
      const {
        transform
      } = e.currentTarget.style;
      let endUp = timeStartUp.value;
      if (transform) {
        endUp = parseFloat(e.currentTarget.style.transform.split(" ")[1].split("px")[0]);
      }
      const distance = Math.abs(endUp - timeStartUp.value);
      const upCount = Math.floor(distance / timeHeight.value) || 1;
      const halfWinWith = timeHeight.value / 2;
      let up = timeStartUp.value;
      if (endUp <= timeStartUp.value) {
        if (distance <= halfWinWith) {
          up = timeStartUp.value;
        } else {
          up = timeStartUp.value - timeHeight.value * upCount;
          if (up < -(timeArray.value[index].length - 3) * timeHeight.value) {
            up = -(timeArray.value[index].length - 3) * timeHeight.value;
          }
        }
      } else if (distance <= halfWinWith) {
        up = timeStartUp.value;
      } else {
        up = timeStartUp.value + timeHeight.value * upCount;
        if (up > timeHeight.value * 2) {
          up = timeHeight.value * 2;
        }
      }
      if (index === 0) {
        const hour = 2 - Math.round(up / timeHeight.value);
        if (formatDisabledDate(hour, index)) {
          up = timeStartUp.value;
        } else {
          checkedDate.value.hours = hour;
        }
      } else {
        const minute = 2 - Math.round(up / timeHeight.value);
        if (formatDisabledDate(minute, index)) {
          up = timeStartUp.value;
        } else {
          checkedDate.value.minutes = minute * props.minuteStep;
        }
      }
      e.currentTarget.style.webkitTransition = "transform 300ms";
      e.currentTarget.style.transform = "translate3d(0px," + up + "px,0px)";
    };
    const timeTouchMove = (e, index) => {
      const moveEndY = e.changedTouches[0].pageY;
      const Y = moveEndY - timeStartY.value;
      e.currentTarget.style.transform = "translate3d(0px," + (Y + timeStartUp.value) + "px,0px)";
      if ((0, import_utils.checkPlatform)() === "2") {
        timeTouchEnd(e, index);
        return false;
      }
    };
    const isBeSelectedTime = (time, index) => index === 0 && time === checkedDate.value.hours || index === 1 && time === checkedDate.value.minutes;
    (0, import_vue2.watch)(() => props.defaultTime, (val) => {
      if (!(val instanceof Date)) {
        throw new Error("The calendar component's defaultTime must be date type!");
      }
      checkedDate.value.hours = val.getHours();
      checkedDate.value.minutes = val.getMinutes();
    }, {
      immediate: true
    });
    (0, import_vue2.watch)(checkedDate, (val) => {
      emit("change", val);
    }, {
      deep: true,
      immediate: true
    });
    (0, import_vue2.watch)(() => props.show, (val) => {
      if (val) {
        setTimeout(() => {
          initTimeArray();
        }, 100);
      }
    }, {
      immediate: true
    });
    (0, import_vue2.watch)(() => props.minuteStep, (val) => {
      if (val <= 0 || val >= 60) {
        throw new Error(`The minutes-step can't be: ${val}!`);
      }
      if (60 % val !== 0) {
        throw new Error("The minutes-step must be divided by 60!");
      }
    }, {
      immediate: true
    });
    const renderTimeItem = (time, index) => time.map((item, j) => (0, import_vue.createVNode)("div", {
      "ref": (ref2) => {
        timeItemRef.length = 0;
        timeItemRef.push(ref2);
      },
      "class": `time_item ${isBeSelectedTime(item, index) ? "time_item_show" : ""} ${formatDisabledDate(item, index) ? "time-disabled" : ""}`,
      "key": index + j
    }, [(0, import_utils.fillNumber)(item)]));
    const renderCalendarTime = () => (0, import_vue.createVNode)("div", {
      "class": "time_body",
      "style": {
        display: props.show ? "flex" : "none"
      }
    }, [(0, import_vue.createVNode)("div", {
      "class": "time_group"
    }, [timeArray.value.map((item, index) => (0, import_vue.createVNode)("div", {
      "class": "time_content",
      "ref": (ref2) => {
        timeContentRef.push(ref2);
      },
      "key": index,
      "onTouchstart": timeTouchStart,
      "onTouchmove": (e) => timeTouchMove(e, index),
      "onTouchend": (e) => timeTouchEnd(e, index)
    }, [renderTimeItem(item, index)]))])]);
    return () => renderCalendarTime();
  }
});
