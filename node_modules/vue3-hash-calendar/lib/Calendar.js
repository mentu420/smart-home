var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var stdin_exports = {};
__export(stdin_exports, {
  calendarProps: () => calendarProps,
  default: () => stdin_default
});
module.exports = __toCommonJS(stdin_exports);
var import_vue = require("vue");
var import_vue2 = require("vue");
var import_constant = require("./constant");
var import_utils = require("./utils");
var import_language = __toESM(require("./language"));
var import_hooks = require("./hooks");
var import_CalendarDate = __toESM(require("./CalendarDate"));
var import_CalendarTime = __toESM(require("./CalendarTime"));
var import_CalendarYearMonth = __toESM(require("./CalendarYearMonth"));
const calendarProps = {
  themeColor: {
    type: Object,
    default: () => ({})
  },
  changeYearFast: Boolean,
  showArrow: Boolean,
  showWeekView: Boolean,
  visible: Boolean,
  disabledWeekView: Boolean,
  showAction: import_utils.truthProp,
  pickerType: (0, import_utils.makeStringProp)("datetime"),
  selectType: (0, import_utils.makeStringProp)("single"),
  defaultYearMonth: {
    type: Object,
    default: {}
  },
  allowSameDay: Boolean,
  showTodayButton: import_utils.truthProp,
  defaultDatetime: [Date, Array],
  minDate: (0, import_utils.makeDateProp)(null),
  maxDate: (0, import_utils.makeDateProp)(null),
  maxRange: (0, import_utils.makeNumberProp)(0),
  format: (0, import_utils.makeStringProp)(""),
  model: (0, import_utils.makeStringProp)("inline"),
  markType: (0, import_utils.makeStringProp)("dot"),
  markDate: (0, import_utils.makeArrayProp)(),
  disabledDate: {
    type: Function,
    default: () => false
  },
  disabledTime: {
    type: Function,
    default: () => false
  },
  lang: (0, import_utils.makeStringProp)("CN"),
  scrollChangeDate: import_utils.truthProp,
  minuteStep: (0, import_utils.makeNumberProp)(1),
  weekStart: (0, import_utils.makeStringProp)("Sunday"),
  disabledScroll: {
    type: [Boolean, String],
    default: () => false
  },
  showNotCurrentMonthDay: import_utils.truthProp,
  firstDayOfMonthClassName: (0, import_utils.makeStringProp)(""),
  todayClassName: (0, import_utils.makeStringProp)(""),
  checkedDayClassName: (0, import_utils.makeStringProp)(""),
  notCurrentMonthDayClassName: (0, import_utils.makeStringProp)(""),
  disabledClassName: (0, import_utils.makeStringProp)("")
};
var stdin_default = (0, import_vue2.defineComponent)({
  name: "VueHashCalendar",
  props: calendarProps,
  emits: ["update:visible", "update:showWeekView", "calendarTypeChange", "click", "confirm", "change", "overRange", "slidechange", "touchstart", "touchmove", "touchend"],
  setup(props, {
    emit,
    slots
  }) {
    const calendarRef = (0, import_vue2.ref)();
    const isShowCalendar = (0, import_vue2.ref)(true);
    const isShowWeek = (0, import_vue2.ref)(props.showWeekView);
    const calendarBodyHeight = (0, import_vue2.ref)(0);
    const firstTimes = (0, import_vue2.ref)(true);
    const currentYearMonth = (0, import_vue2.ref)({
      year: new Date().getFullYear(),
      month: new Date().getMonth()
    });
    const limitDateRange = (date, minDate = props.minDate, maxDate = props.maxDate) => {
      if (minDate && (0, import_utils.compareDay)((0, import_utils.transDateToYearMonthDay)(date), (0, import_utils.transDateToYearMonthDay)(minDate)) === -1) {
        return minDate;
      }
      if (maxDate && (0, import_utils.compareDay)((0, import_utils.transDateToYearMonthDay)(date), (0, import_utils.transDateToYearMonthDay)(maxDate)) === 1) {
        return maxDate;
      }
      return date;
    };
    const getInitialDateTime = (defaultDatetime = props.defaultDatetime) => {
      const {
        selectType,
        minDate,
        maxDate,
        allowSameDay
      } = props;
      if (defaultDatetime === null)
        return defaultDatetime;
      const nowDate = (0, import_utils.getToday)();
      const nowDatetime = new Date();
      if (selectType === "range") {
        if (!Array.isArray(defaultDatetime)) {
          defaultDatetime = [];
        }
        const start = limitDateRange(defaultDatetime[0] || nowDate, minDate, allowSameDay ? maxDate : (0, import_utils.getPrevDay)((0, import_utils.transDateToYearMonthDay)(maxDate)));
        const end = limitDateRange(defaultDatetime[1] || nowDate, allowSameDay ? minDate : (0, import_utils.getNextDay)((0, import_utils.transDateToYearMonthDay)(minDate)));
        return [start, end];
      }
      if (selectType === "multiple") {
        if (Array.isArray(defaultDatetime)) {
          return defaultDatetime.map((date) => limitDateRange(date));
        }
        return [limitDateRange(nowDate)];
      }
      if (!defaultDatetime || Array.isArray(defaultDatetime)) {
        defaultDatetime = nowDatetime;
      }
      return limitDateRange(defaultDatetime);
    };
    const currDateTime = (0, import_vue2.ref)(getInitialDateTime());
    const checkedDate = (0, import_vue2.ref)([(0, import_utils.transDateToHourMinute)(new Date())]);
    const yearMonthType = (0, import_vue2.ref)("date");
    const isShowDatetimePicker = (0, import_vue2.computed)({
      get() {
        return props.model === "inline" ? true : props.visible;
      },
      set(val) {
        emit("update:visible", val);
      }
    });
    const isShowArrowImg = (0, import_vue2.computed)(() => props.showArrow && props.model === "inline");
    const calendarContentHeight = (0, import_vue2.computed)(() => {
      if (props.pickerType === "time") {
        return 245;
      }
      return calendarBodyHeight.value;
    });
    const slideChange = (direction) => {
      emit("slidechange", direction);
    };
    const toggleWeek = () => {
      isShowWeek.value = !isShowWeek.value;
      if (isShowWeek.value)
        slideChange("up");
      else
        slideChange("down");
    };
    const today = () => {
      var _a;
      if (props.disabledDate(new Date()))
        return;
      (_a = calendarRef.value) == null ? void 0 : _a.today();
    };
    const reset = (date = getInitialDateTime()) => {
      currDateTime.value = date;
    };
    const lastMonth = () => {
      var _a;
      (_a = calendarRef.value) == null ? void 0 : _a.getLastMonth();
    };
    const nextMonth = () => {
      var _a;
      (_a = calendarRef.value) == null ? void 0 : _a.getNextMonth();
    };
    const lastWeek = () => {
      var _a, _b;
      (_a = calendarRef.value) == null ? void 0 : _a.getLastMonth();
      (_b = calendarRef.value) == null ? void 0 : _b.changeWeekView({
        isNext: false
      });
    };
    const nextWeek = () => {
      var _a, _b;
      (_a = calendarRef.value) == null ? void 0 : _a.getNextMonth();
      (_b = calendarRef.value) == null ? void 0 : _b.changeWeekView({
        isNext: true
      });
    };
    const dateChange = (date) => {
      if (props.selectType === "single") {
        checkedDate.value = [__spreadValues(__spreadValues({}, checkedDate.value[0]), date[0])];
      } else {
        checkedDate.value = date;
      }
    };
    const dateClick = (date) => {
      if (!date.day)
        return;
      let fDate;
      if (props.selectType === "single") {
        const checked = checkedDate.value[0];
        date.minutes = checked.minutes;
        date.hours = checked.hours;
        fDate = (0, import_utils.transHourMinuteToDate)(date);
      } else {
        fDate = (0, import_utils.transYearMontDayToDate)(date);
      }
      currDateTime.value = new Date(fDate);
      if (props.format) {
        fDate = (0, import_utils.formatDate)(fDate, props.format, props.lang);
      }
      emit("click", fDate);
    };
    const yearMonthClick = (date, type) => {
      if (type) {
        switch (type) {
          case "yearRange":
            yearMonthType.value = "year";
            break;
          case "year":
            yearMonthType.value = "month";
            break;
          case "month":
            yearMonthType.value = "date";
            break;
        }
        emit("calendarTypeChange", yearMonthType.value);
      }
      currentYearMonth.value = {
        year: date.year,
        month: date.month
      };
      dateClick(date);
      if (props.selectType === "single") {
        const {
          day,
          hours,
          minutes
        } = checkedDate.value[0];
        let emitDate = (0, import_utils.transHourMinuteToDate)(__spreadProps(__spreadValues({}, currentYearMonth.value), {
          day,
          hours,
          minutes
        }));
        if (props.format) {
          emitDate = (0, import_utils.formatDate)(emitDate, props.format, props.lang);
        }
        emit("change", emitDate);
      }
    };
    const timeChange = (date) => {
      const {
        minutes,
        hours
      } = date;
      const checked = checkedDate.value[0];
      checkedDate.value = [__spreadProps(__spreadValues({}, checked), {
        minutes,
        hours
      })];
    };
    const close = () => {
      isShowDatetimePicker.value = false;
    };
    const makeEmitDate = () => {
      const dateArr = checkedDate.value.map((item) => {
        let date = (0, import_utils.transYearMontDayToDate)(item);
        if (props.selectType === "single") {
          date = (0, import_utils.transHourMinuteToDate)(item);
        }
        if (props.format) {
          return (0, import_utils.formatDate)(date, props.format, props.lang);
        }
        return date;
      });
      if (props.selectType === "single") {
        return dateArr[0];
      }
      return dateArr;
    };
    const confirm = () => {
      emit("confirm", makeEmitDate());
      if (props.model === "dialog") {
        close();
      }
    };
    const formatDatetime = (time, format) => (0, import_utils.formatDate)(time, format, props.lang);
    const showYearMonthPicker = () => {
      if (!props.changeYearFast)
        return;
      if (yearMonthType.value === "date") {
        yearMonthType.value = "month";
      } else if (yearMonthType.value === "month") {
        yearMonthType.value = "year";
      } else if (yearMonthType.value === "year") {
        yearMonthType.value = "yearRange";
      } else {
        yearMonthType.value = "date";
      }
      emit("calendarTypeChange", yearMonthType.value);
    };
    const showCalendar = () => {
      if (isShowCalendar.value) {
        showYearMonthPicker();
      } else {
        emit("calendarTypeChange", "date");
      }
      isShowCalendar.value = true;
    };
    const showTime = () => {
      isShowCalendar.value = false;
      emit("calendarTypeChange", "time");
      yearMonthType.value = "date";
    };
    const heightChange = (height) => {
      if (!firstTimes.value && props.model === "dialog")
        return;
      calendarBodyHeight.value = height;
      firstTimes.value = false;
    };
    const getThemeColor = () => {
      const cssVar = {};
      if (props.themeColor) {
        const themeColorKeys = Object.keys(props.themeColor || {});
        if (themeColorKeys.length) {
          themeColorKeys.forEach((k) => {
            cssVar[`--hash-calendar-${k}`] = props.themeColor[k];
          });
        }
      }
      return cssVar;
    };
    const touchStart = (event) => {
      emit("touchstart", event);
    };
    const touchMove = (event) => {
      emit("touchmove", event);
    };
    const touchEnd = (event) => {
      emit("touchend", event);
    };
    (0, import_vue2.watch)(checkedDate, () => {
      const emitDate = makeEmitDate();
      if (props.selectType === "range" && Array.isArray(emitDate) && emitDate.length === 1) {
        return;
      }
      emit("change", emitDate);
    }, {
      deep: true
    });
    (0, import_vue2.watch)(() => props.showWeekView, (val) => {
      isShowWeek.value = val;
    });
    (0, import_vue2.watch)(() => [props.selectType, props.minDate, props.maxDate], () => {
      if (props.selectType === "single") {
        reset(getInitialDateTime());
      } else {
        reset(getInitialDateTime(currDateTime.value));
      }
    });
    (0, import_hooks.useExpose)({
      today,
      reset,
      lastMonth,
      nextMonth,
      lastWeek,
      nextWeek
    });
    const init = () => {
      const date = currDateTime.value;
      if (!date) {
        checkedDate.value = [];
      } else if (date instanceof Date) {
        currentYearMonth.value = {
          year: date.getFullYear(),
          month: date.getMonth()
        };
        checkedDate.value = [(0, import_utils.transDateToHourMinute)(date)];
      } else if (Array.isArray(date)) {
        if (props.selectType === "range") {
          const dateArr = (0, import_utils.calcMiddleDay)([__spreadProps(__spreadValues({}, (0, import_utils.transDateToHourMinute)(date[0])), {
            type: "start"
          }), __spreadProps(__spreadValues({}, (0, import_utils.transDateToHourMinute)(date[1])), {
            type: "end"
          })]);
          checkedDate.value = dateArr.map((item) => (0, import_utils.transDateToHourMinute)((0, import_utils.transYearMontDayToDate)(item)));
        } else {
          checkedDate.value = date.map((item) => (0, import_utils.transDateToHourMinute)(item));
        }
      }
      if (props.pickerType === "time") {
        showTime();
      } else {
        isShowCalendar.value = true;
      }
    };
    (0, import_hooks.useMountedOrActivated)(init);
    const renderTodayButton = () => {
      let todayEle = import_language.default[props.lang].TODAY;
      if (slots.today) {
        todayEle = slots.today();
      }
      if (props.showTodayButton) {
        return (0, import_vue.createVNode)("div", {
          "class": `calendar_confirm ${props.disabledDate(new Date()) ? "today_disable" : ""}`,
          "onClick": today
        }, [todayEle]);
      }
    };
    const renderConfirmButton = () => {
      let confirmEle = import_language.default[props.lang].CONFIRM;
      if (slots.confirm) {
        confirmEle = slots.confirm();
      }
      if (props.model === "dialog") {
        return (0, import_vue.createVNode)("div", {
          "class": "calendar_confirm",
          "onClick": confirm
        }, [confirmEle]);
      }
    };
    const renderAction = () => {
      let timeText = "";
      const {
        year,
        month
      } = currentYearMonth.value;
      let dateText = formatDatetime(`${year}/${month + 1}`, import_language.default[props.lang].DEFAULT_YEAR_MONTH_FORMAT);
      if (props.selectType === "single") {
        const {
          day,
          hours,
          minutes
        } = checkedDate.value[0];
        timeText = formatDatetime(`${year}/${month + 1}/${day} ${(0, import_utils.fillNumber)(hours)}:${(0, import_utils.fillNumber)(minutes)}`, import_language.default[props.lang].DEFAULT_TIME_FORMAT);
        dateText = formatDatetime(`${year}/${month + 1}/${day}`, import_language.default[props.lang].DEFAULT_DATE_FORMAT);
      }
      if (props.showAction) {
        return (0, import_vue.createVNode)("div", {
          "class": "calendar_title",
          "onClick": (e) => {
            if (e.cancelable)
              e.preventDefault();
            e.stopPropagation();
          },
          "style": {
            bottom: props.model === "dialog" ? `${calendarContentHeight.value}px` : "unset"
          }
        }, [slots.action ? slots.action() : (0, import_vue.createVNode)(import_vue.Fragment, null, [(0, import_vue.createVNode)("div", {
          "class": "calendar_title_date"
        }, [props.pickerType !== "time" ? (0, import_vue.createVNode)("span", {
          "class": `calendar_title_date_year ${isShowCalendar.value ? "calendar_title_date_active" : ""}`,
          "onClick": showCalendar
        }, [dateText]) : null, props.pickerType !== "date" && props.selectType === "single" ? (0, import_vue.createVNode)("span", {
          "class": `calendar_title_date_time ${!isShowCalendar.value ? "calendar_title_date_active" : ""}`,
          "onClick": showTime
        }, [timeText]) : null]), renderTodayButton(), renderConfirmButton()])]);
      }
      return null;
    };
    const updateShowWeekView = (val) => {
      if (isShowWeek.value === val)
        return;
      if (val) {
        emit("calendarTypeChange", "week");
      } else {
        emit("calendarTypeChange", "date");
      }
      isShowWeek.value = val;
    };
    const yearMonthChange = (yearMonth) => {
      currentYearMonth.value = yearMonth;
    };
    const renderCalendar = () => (0, import_vue.createVNode)(import_CalendarDate.default, (0, import_vue.mergeProps)({
      "ref": calendarRef,
      "show": isShowCalendar.value,
      "onHeight": heightChange,
      "defaultDate": currDateTime.value,
      "onTouchstart": touchStart,
      "onTouchmove": touchMove,
      "onTouchend": touchEnd,
      "onSlidechange": slideChange,
      "onYearMonthChange": yearMonthChange,
      "onChange": dateChange,
      "onOverRange": () => emit("overRange"),
      "onClick": dateClick,
      "showWeekView": isShowWeek.value,
      "onUpdate:showWeekView": updateShowWeekView
    }, (0, import_utils.pick)(props, ["minDate", "maxDate", "maxRange", "disabledWeekView", "markType", "selectType", "allowSameDay", "defaultYearMonth", "markDate", "disabledDate", "lang", "weekStart", "disabledScroll", "scrollChangeDate", "showNotCurrentMonthDay", "firstDayOfMonthClassName", "todayClassName", "checkedDayClassName", "notCurrentMonthDayClassName", "disabledClassName"])), (0, import_utils.pick)(slots, ["week", "day"]));
    const renderTimePicker = () => {
      if (props.pickerType === "datetime" || props.pickerType === "time") {
        return (0, import_vue.createVNode)(import_CalendarTime.default, (0, import_vue.mergeProps)({
          "show": !isShowCalendar.value,
          "defaultTime": currDateTime.value,
          "calendarDate": checkedDate.value[0],
          "onChange": timeChange
        }, (0, import_utils.pick)(props, ["minuteStep", "disabledTime"])), null);
      }
    };
    const renderYearMonthPicker = () => (0, import_vue.createVNode)(import_CalendarYearMonth.default, (0, import_vue.mergeProps)({
      "calendarContentHeight": calendarContentHeight.value,
      "currentYearMonth": currentYearMonth.value,
      "type": yearMonthType.value,
      "onTouchstart": touchStart,
      "onTouchmove": touchMove,
      "onTouchend": touchEnd,
      "onSlidechange": slideChange,
      "onClick": yearMonthClick
    }, (0, import_utils.pick)(props, ["minDate", "maxDate", "disabledDate", "lang", "disabledScroll", "checkedDayClassName", "notCurrentMonthDayClassName", "disabledClassName"])), null);
    const renderCtrlImg = () => {
      let confirmEle = (0, import_vue.createVNode)("img", {
        "src": isShowWeek.value ? import_constant.ARROW_DOWN_IMG : import_constant.ARROW_UP_IMG
      }, null);
      if (slots.arrow) {
        confirmEle = slots.arrow({
          isShowWeek: isShowWeek.value
        });
      }
      if (isShowArrowImg.value) {
        return (0, import_vue.createVNode)("div", {
          "class": "ctrl-img",
          "onClick": toggleWeek,
          "style": {
            "margin-top": props.model === "dialog" ? `${calendarContentHeight.value}px` : "unset"
          }
        }, [confirmEle]);
      }
    };
    const renderHashCalendar = () => {
      if (isShowDatetimePicker.value || props.model === "inline") {
        return (0, import_vue.createVNode)("div", {
          "class": `hash-calendar ${props.model === "inline" ? "calendar_inline" : ""}`,
          "style": __spreadValues({}, getThemeColor()),
          "onClick": close
        }, [renderAction(), (0, import_vue.createVNode)("div", {
          "class": "calendar_content",
          "style": {
            height: `${calendarContentHeight.value}px`
          },
          "onClick": (e) => {
            if (e.cancelable)
              e.preventDefault();
            e.stopImmediatePropagation();
          }
        }, [props.pickerType !== "time" ? renderCalendar() : "", props.selectType === "single" && renderTimePicker(), props.changeYearFast ? renderYearMonthPicker() : ""]), renderCtrlImg()]);
      }
    };
    return () => renderHashCalendar();
  }
});
