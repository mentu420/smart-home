import { getCurrentInstance, onMounted, nextTick, onActivated, unref, defineComponent, ref, reactive, computed, watch, createVNode, Fragment, mergeProps } from "vue";
const ARROW_DOWN_IMG = "data:image/png;base64,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";
const ARROW_UP_IMG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAANp0lEQVR4Xu2dbYwdZRXHz7m7l94LSsluKr6kwRqINQtsd2Y0kagxEqsfNFFJipSKTTUajRWKEcSWlhIltFhE40uCWAotGDDRDxg1kcQPSk3MzNysa1HTagMYI5WtvNTQ7C5zzFOngLAv954789y59/zna+c8z5zfmV/PnX3uM5cJBwiAwIIEGGxAAAQWJgBBcHeAwCIEIAhuDxCAILgHQEBHAB1Exw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAECOFRpo6AhBExw1RRghAEI+FfuKJJ5pPPfXU2izLJk5PKyLP1Wq1XwRB8KjHS8FUbRKAIG2C6ua0NE3fmWXZ9US0lpmbC4x1hIgOjIyM7Fq1atXJbuZDbHEEIEhxLOcdKUmS3UT05XanEZG/Dg0NXTUxMXGw3RicVx4BCFIS28nJyQvn5uYeJKK3KabIROSO0dHRregmCnoFhkCQAmG6oUSkliTJdcy8k4jO6HL4I0NDQ1euWbPm912Og3AlAQiiBDdf2OTk5Kq5ubkDRHRJgcOimxQIs9OhIEinxBY4P0mSzxDRHiJ6TUFDvnIYdJOSwC42LATpEnqapitE5F4i+mCXQ7UT7rrJN0dHR7fh2aQdXN2fA0G6YJgkyUdF5AfMPNrFMJpQdBMNNUUMBFFAO3z48NnPPvvsd4logyK8qBB0k6JILjIOBOkQcpIk7yMi95HqTR2GlnU6uklZ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";
const truthProp = {
  type: Boolean,
  default: true
};
const makeArrayProp = () => ({
  type: Array,
  default: () => []
});
const makeNumberProp = (defaultVal) => ({
  type: Number,
  default: defaultVal
});
const makeStringProp = (defaultVal) => ({
  type: String,
  default: defaultVal
});
const makeDateProp = (defaultVal) => ({
  type: Date,
  validator: isDate,
  default: defaultVal
});
var stdin_default$8 = {
  CONFIRM: "\u786E\u5B9A",
  TODAY: "\u4ECA\u5929",
  WEEK: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
  MONTH: [
    "1\u6708",
    "2\u6708",
    "3\u6708",
    "4\u6708",
    "5\u6708",
    "6\u6708",
    "7\u6708",
    "8\u6708",
    "9\u6708",
    "10\u6708",
    "11\u6708",
    "12\u6708"
  ],
  DEFAULT_DATE_FORMAT: "YY\u5E74MM\u6708DD\u65E5",
  DEFAULT_YEAR_MONTH_FORMAT: "YY\u5E74MM\u6708",
  DEFAULT_TIME_FORMAT: "hh:mm"
};
var stdin_default$7 = {
  CONFIRM: "CONFIRM",
  TODAY: "TODAY",
  WEEK: ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"],
  MONTH: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sept",
    "Oct",
    "Nov",
    "Dec"
  ],
  DEFAULT_DATE_FORMAT: "MM DD,YY",
  DEFAULT_YEAR_MONTH_FORMAT: "DD,YY",
  DEFAULT_TIME_FORMAT: "at hh:mm F"
};
var stdin_default$6 = {
  CN: stdin_default$8,
  EN: stdin_default$7
};
var __defProp$3 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
const formatDate = function(time, format, lang = "CN") {
  const languageEntiy = stdin_default$6[lang] || {};
  format = format || `${languageEntiy.DEFAULT_DATE_FORMAT} ${languageEntiy.DEFAULT_TIME_FORMAT}`;
  const date = time ? new Date(time) : new Date();
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  const hour = date.getHours();
  const min = date.getMinutes();
  const sec = date.getSeconds();
  const preArr = Array.apply(null, Array(10)).map((elem, index) => "0" + index);
  const newTime = format.replace(/YY/g, year + "").replace(/F/g, hour >= 12 ? "pm" : "am").replace(/ss/g, preArr[sec] || sec + "").replace(/mm/g, preArr[min] || min + "").replace(
    /hh/g,
    hour > 12 && format.includes("F") ? hour - 12 + "" : format.includes("F") ? hour + "" : preArr[hour] || hour + ""
  ).replace(/DD/g, preArr[day] || day + "").replace(
    /MM/g,
    lang === "EN" ? languageEntiy.MONTH[month - 1] : preArr[month] || month + ""
  );
  return newTime;
};
const fillNumber = (val) => val > 9 ? val : "0" + val;
const daysOfMonth = (year) => [
  31,
  28 + isLeap(year),
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
const getDayOfWeek = (year = new Date().getFullYear(), month = new Date().getMonth(), day = 1) => {
  const dayOfMonth = new Date(year, month, day);
  const dayOfWeek = dayOfMonth.getDay();
  return dayOfWeek;
};
function pick(obj, keys, ignoreUndefined) {
  return keys.reduce((ret, key) => {
    if (!ignoreUndefined || obj[key] !== void 0) {
      ret[key] = obj[key];
    }
    return ret;
  }, {});
}
const transDateToYearMonthDay = (date) => {
  if (!date)
    return date;
  return {
    year: date.getFullYear(),
    month: date.getMonth(),
    day: date.getDate()
  };
};
const transDateToHourMinute = (date) => {
  if (!date)
    return date;
  return {
    year: date.getFullYear(),
    month: date.getMonth(),
    day: date.getDate(),
    hours: date.getHours(),
    minutes: date.getMinutes()
  };
};
const transYearMontDayToDate = (date) => {
  const { year, month, day } = date;
  return new Date(year, month, day, 0, 0, 0, 0);
};
const transHourMinuteToDate = (date) => {
  const { year, month, day, minutes, hours } = date;
  return new Date(
    transYearMontDayToDate({ year, month, day }).setHours(hours, minutes, 0, 0)
  );
};
const getMinDate = (min) => min && new Date(min.setHours(0, 0, 0, 0)).getTime() - 24 * 60 * 60 * 1e3;
const getMaxDate = (max) => max && new Date(max.setHours(0, 0, 0, 0)).getTime() + 24 * 60 * 60 * 1e3;
function compareMonth(date1, date2) {
  const year1 = date1.year;
  const year2 = date2.year;
  if (year1 === year2) {
    const month1 = date1.month;
    const month2 = date2.month;
    return month1 === month2 ? 0 : month1 > month2 ? 1 : -1;
  }
  return year1 > year2 ? 1 : -1;
}
function compareDay(day1, day2) {
  const compareMonthResult = compareMonth(day1, day2);
  if (compareMonthResult === 0) {
    const date1 = day1.day;
    const date2 = day2.day;
    return date1 === date2 ? 0 : date1 > date2 ? 1 : -1;
  }
  return compareMonthResult;
}
const cloneDate = (date) => new Date(date);
function getDayByOffset(date, offset) {
  const cloned = cloneDate(date);
  cloned.setDate(cloned.getDate() + offset);
  return cloned;
}
const getPrevDay = (date) => {
  if (!date)
    return date;
  const currDate = transYearMontDayToDate(date);
  return getDayByOffset(currDate, -1);
};
const getNextDay = (date) => {
  if (!date)
    return date;
  const currDate = transYearMontDayToDate(date);
  return getDayByOffset(currDate, 1);
};
const getToday = () => {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  return today;
};
function calcDateNum(date) {
  const day1 = date[0].getTime();
  const day2 = date[1].getTime();
  return (day2 - day1) / (1e3 * 60 * 60 * 24) + 1;
}
function calcMiddleDay(date) {
  const [date1, date2] = date.map((item) => transYearMontDayToDate(item));
  const dateNum = calcDateNum([date1, date2]);
  if (dateNum > 2) {
    let nextDate = __spreadProps$3(__spreadValues$3({}, date[0]), { type: "start" });
    const dateArr = [];
    while (compareDay(nextDate, date[1]) === -1) {
      dateArr.push(nextDate);
      nextDate = __spreadProps$3(__spreadValues$3({}, transDateToYearMonthDay(getNextDay(nextDate))), {
        type: "middle"
      });
    }
    return [...dateArr, __spreadProps$3(__spreadValues$3({}, date[1]), { type: "end" })];
  }
  return date;
}
const getStartEndDay = (date) => {
  const [start, end] = date;
  if (date.length <= 2) {
    return [start, end];
  }
  return [start, date[date.length - 1]];
};
const checkPlatform = function() {
  if (/android/i.test(navigator.userAgent)) {
    return "1";
  }
  if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) {
    return "2";
  }
};
const isDateInRange = (curr, min, max) => {
  const minDate = getMinDate(min);
  const maxDate = getMaxDate(max);
  const currentDate = new Date(curr.setHours(0, 0, 0, 0)).getTime();
  if (minDate && maxDate)
    return currentDate > minDate && currentDate < maxDate;
  if (minDate)
    return currentDate > minDate;
  if (maxDate)
    return currentDate < maxDate;
  return true;
};
const isWindow = (val) => val === window;
const isDate = (val) => Object.prototype.toString.call(val) === "[object Date]" && !Number.isNaN(val.getTime());
const isLeap = (year) => year % 4 === 0 ? year % 100 !== 0 ? 1 : year % 400 === 0 ? 1 : 0 : 0;
const withInstall = (options) => {
  options.install = (app) => {
    const { name } = options;
    if (name) {
      app.component(name, options);
    }
  };
  return options;
};
function useExpose(apis) {
  const instance = getCurrentInstance();
  if (instance) {
    Object.assign(instance.proxy, apis);
  }
}
const useMountedOrActivated = (hook) => {
  let mounted;
  onMounted(() => {
    hook();
    nextTick(() => {
      mounted = true;
    });
  });
  onActivated(() => {
    if (mounted) {
      hook();
    }
  });
};
const makeDOMRect = (width, height) => ({
  top: 0,
  left: 0,
  right: width,
  bottom: height,
  width,
  height
});
const useRect = (elementOrRef) => {
  const element = unref(elementOrRef);
  if (isWindow(element)) {
    const width = element.innerWidth;
    const height = element.innerHeight;
    return makeDOMRect(width, height);
  }
  if (element == null ? void 0 : element.getBoundingClientRect) {
    return element.getBoundingClientRect();
  }
  return makeDOMRect(0, 0);
};
var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
const calendarDateProps = {
  showWeekView: Boolean,
  show: Boolean,
  disabledWeekView: Boolean,
  selectType: makeStringProp("single"),
  allowSameDay: Boolean,
  defaultDate: [Date, Array],
  defaultYearMonth: {
    type: Object,
    default: {}
  },
  minDate: makeDateProp(null),
  maxDate: makeDateProp(null),
  maxRange: makeNumberProp(0),
  markType: makeStringProp("dot"),
  markDate: makeArrayProp(),
  disabledDate: {
    type: Function,
    default: () => false
  },
  lang: makeStringProp("CN"),
  scrollChangeDate: truthProp,
  weekStart: makeStringProp("Sunday"),
  disabledScroll: {
    type: [Boolean, String],
    default: () => false
  },
  showNotCurrentMonthDay: truthProp,
  firstDayOfMonthClassName: makeStringProp(""),
  todayClassName: makeStringProp(""),
  checkedDayClassName: makeStringProp(""),
  notCurrentMonthDayClassName: makeStringProp(""),
  disabledClassName: makeStringProp("")
};
var stdin_default$5 = defineComponent({
  name: "CalendarDate",
  props: calendarDateProps,
  emits: ["height", "update:showWeekView", "click", "change", "overRange", "yearMonthChange", "slidechange", "touchstart", "touchmove", "touchend"],
  setup(props, {
    emit,
    slots
  }) {
    const weekTitleRef = ref(null);
    const calendarRef = ref(null);
    const calendarItemRef = reactive([]);
    const yearOfToday = ref(new Date().getFullYear());
    const monthOfToday = ref(new Date().getMonth());
    const dayOfToday = ref(new Date().getDate());
    const weekArray = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
    const calendarWeek = ref(["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"]);
    const calendarOfMonth = ref([]);
    const calendarOfMonthShow = ref([]);
    const calendarDaysTotalLength = ref(42);
    const lastMonthYear = ref(0);
    const lastMonth = ref(0);
    const nextMonthYear = ref(0);
    const nextMonth = ref(0);
    const checkedDate = ref([]);
    const weekStartIndex = ref(0);
    const translateIndex = ref(0);
    const transitionDuration = ref(0.3);
    const touch = ref({
      x: 0,
      y: 0
    });
    const isTouching = ref(false);
    const calendarGroupHeight = ref(0);
    const calendarWeekTitleHeight = ref(0);
    const calendarItemHeight = ref(0);
    const touchStartPositionX = ref(0);
    const touchStartPositionY = ref(0);
    const calendarY = ref(0);
    const selectedDayIndex = ref(0);
    const lastWeek = ref([]);
    const nextWeek = ref([]);
    const isLastWeekInCurrentMonth = ref(false);
    const isNextWeekInCurrentMonth = ref(false);
    const markDateColorObj = ref({});
    const markDateTypeObj = ref({});
    const currentYearMonth = ref({
      year: new Date().getFullYear(),
      month: new Date().getMonth()
    });
    calendarWeek.value = stdin_default$6[props.lang].WEEK;
    weekStartIndex.value = weekArray.indexOf(props.weekStart.toLowerCase());
    calendarWeek.value = [...calendarWeek.value.slice(weekStartIndex.value, calendarWeek.value.length), ...calendarWeek.value.slice(0, weekStartIndex.value)];
    const isShowWeek = computed({
      get() {
        return props.showWeekView;
      },
      set(val) {
        emit("update:showWeekView", val);
      }
    });
    const showWeek = (checkedDatetime) => {
      if (!checkedDatetime) {
        checkedDatetime = checkedDate.value[0];
      }
      const {
        month,
        day
      } = checkedDatetime;
      const daysArr = [];
      calendarOfMonth.value[1].forEach((item) => {
        daysArr.push(item.day);
      });
      let dayIndexOfMonth = daysArr.indexOf(day);
      if (day > 15) {
        dayIndexOfMonth = daysArr.lastIndexOf(day);
      }
      const indexOfLine = Math.ceil((dayIndexOfMonth + 1) / 7);
      const lastLine = indexOfLine - 1;
      calendarY.value = -(calendarItemHeight.value * lastLine);
      isShowWeek.value = true;
      calendarGroupHeight.value = calendarItemHeight.value;
      let currentWeek = [];
      const sliceStart = lastLine * 7;
      const sliceEnd = sliceStart + 7;
      isLastWeekInCurrentMonth.value = false;
      currentWeek = calendarOfMonth.value[1].slice(sliceStart, sliceEnd);
      currentWeek.forEach((item, index) => {
        if (item.day === day) {
          selectedDayIndex.value = index;
        }
      });
      const firstDayOfCurrentWeek = currentWeek[0];
      const lastDayOfCurrentWeek = currentWeek[6];
      if (firstDayOfCurrentWeek.month !== month || firstDayOfCurrentWeek.day === 1) {
        if (calendarOfMonth.value[0].slice(28, 35)[6].month !== month) {
          lastWeek.value = calendarOfMonth.value[0].slice(28, 35);
        } else {
          lastWeek.value = calendarOfMonth.value[0].slice(21, 28);
        }
      } else {
        lastWeek.value = calendarOfMonth.value[1].slice(sliceStart - 7, sliceEnd - 7);
        if (lastWeek.value[selectedDayIndex.value] && lastWeek.value[selectedDayIndex.value].month === month) {
          isLastWeekInCurrentMonth.value = true;
        }
      }
      isNextWeekInCurrentMonth.value = false;
      if (lastDayOfCurrentWeek.day < firstDayOfCurrentWeek.day && lastDayOfCurrentWeek.month !== month) {
        nextWeek.value = calendarOfMonth.value[2].slice(7, 14);
      } else if (lastDayOfCurrentWeek.day === daysOfMonth(lastDayOfCurrentWeek.year)[lastDayOfCurrentWeek.month]) {
        nextWeek.value = calendarOfMonth.value[2].slice(0, 7);
      } else {
        nextWeek.value = calendarOfMonth.value[1].slice(sliceStart + 7, sliceEnd + 7);
        if (nextWeek.value[selectedDayIndex.value].month === month) {
          isNextWeekInCurrentMonth.value = true;
        }
      }
      calendarOfMonthShow.value[0].splice(sliceStart, 7, ...lastWeek.value);
      calendarOfMonthShow.value[2].splice(sliceStart, 7, ...nextWeek.value);
    };
    const isNotCurrentMonthDay = (date, index) => {
      const dateOfCurrentShow = calendarOfMonth.value[index][15];
      return date.year !== dateOfCurrentShow.year || date.month !== dateOfCurrentShow.month;
    };
    const isFirstDayOfMonth = (date, i) => date.day === 1 && !isNotCurrentMonthDay(date, i);
    const formatDisabledDate = (date) => {
      if (!date.day)
        return;
      const fDate = new Date(`${date.year}/${date.month + 1}/${date.day}`);
      return props.disabledDate(fDate) || !isDateInRange(fDate, props.minDate, props.maxDate);
    };
    const calculateCalendarOfMonth = (year = new Date().getFullYear(), month = new Date().getMonth()) => {
      const calendarOfCurrentMonth = [];
      const lastMonthYear2 = month === 0 ? year - 1 : year;
      const lastMonth2 = month === 0 ? 11 : month - 1;
      const nextMonthYear2 = month === 11 ? year + 1 : year;
      const nextMonth2 = month === 11 ? 0 : month + 1;
      let dayOfWeek = getDayOfWeek(year, month);
      const lastMonthDays = daysOfMonth(year)[lastMonth2];
      if (dayOfWeek < weekStartIndex.value) {
        dayOfWeek = 7 - weekStartIndex.value + dayOfWeek;
      } else {
        dayOfWeek -= weekStartIndex.value;
      }
      for (let i = 0; i < dayOfWeek; i++) {
        calendarOfCurrentMonth.push({
          year: lastMonthYear2,
          month: lastMonth2,
          day: props.showNotCurrentMonthDay ? lastMonthDays - (dayOfWeek - 1 - i) : 0
        });
      }
      for (let i = 0; i < daysOfMonth(year)[month]; i++) {
        calendarOfCurrentMonth.push({
          year,
          month,
          day: i + 1
        });
      }
      const fillDays = calendarDaysTotalLength.value - calendarOfCurrentMonth.length;
      for (let i = 0; i < fillDays; i++) {
        calendarOfCurrentMonth.push({
          year: nextMonthYear2,
          month: nextMonth2,
          day: props.showNotCurrentMonthDay ? i + 1 : 0
        });
      }
      return calendarOfCurrentMonth;
    };
    const calculateCalendarOfThreeMonth = (year = currentYearMonth.value.year, month = currentYearMonth.value.month) => {
      lastMonthYear.value = month === 0 ? year - 1 : year;
      lastMonth.value = month === 0 ? 11 : month - 1;
      nextMonthYear.value = month === 11 ? year + 1 : year;
      nextMonth.value = month === 11 ? 0 : month + 1;
      const firstMonth = calculateCalendarOfMonth(lastMonthYear.value, lastMonth.value);
      const secondMonth = calculateCalendarOfMonth(year, month);
      const thirdMonth = calculateCalendarOfMonth(nextMonthYear.value, nextMonth.value);
      calendarOfMonth.value = [];
      calendarOfMonth.value.push(firstMonth, secondMonth, thirdMonth);
      calendarOfMonthShow.value = JSON.parse(JSON.stringify(calendarOfMonth.value));
      if (!props.scrollChangeDate)
        return;
      if (props.selectType === "single") {
        let tempDate = {};
        let {
          day
        } = checkedDate.value[0];
        if (day > 30 || day > 28 && month === 1) {
          day = daysOfMonth(year)[month];
        }
        tempDate = {
          day,
          year,
          month
        };
        if (formatDisabledDate(tempDate))
          return;
        const {
          year: preYear,
          month: preMonth,
          day: preDay
        } = checkedDate.value[0];
        if (preYear !== year || preMonth !== month || preDay !== day) {
          checkedDate.value = [{
            day: tempDate.day,
            year,
            month
          }];
        }
      }
    };
    const showMonth = () => {
      calendarY.value = 0;
      isShowWeek.value = false;
      calendarGroupHeight.value = calendarItemHeight.value * 6;
      isLastWeekInCurrentMonth.value = false;
      isNextWeekInCurrentMonth.value = false;
      calculateCalendarOfThreeMonth();
    };
    const init = () => {
      if (props.selectType === "single") {
        const {
          year,
          month
        } = checkedDate.value[0];
        currentYearMonth.value = {
          year,
          month
        };
      }
      nextTick(() => {
        calendarItemHeight.value = useRect(calendarItemRef[0]).height;
        calendarWeekTitleHeight.value = useRect(weekTitleRef).height;
        const calendarItemGroup = calendarItemRef || [];
        calendarItemGroup.forEach((item) => {
          if (!item)
            return;
          item.style.height = `${calendarItemHeight.value}px`;
        });
        if (isShowWeek.value) {
          showWeek();
          calendarGroupHeight.value = calendarItemHeight.value;
        } else {
          showMonth();
          calendarGroupHeight.value = calendarItemHeight.value * 6;
        }
      });
    };
    const today = () => {
      const {
        year,
        month,
        day
      } = transDateToYearMonthDay(new Date());
      if (props.selectType === "single") {
        checkedDate.value = [{
          year,
          month,
          day
        }];
      }
      currentYearMonth.value = {
        year,
        month
      };
      calculateCalendarOfThreeMonth();
      if (isShowWeek.value) {
        setTimeout(() => {
          isTouching.value = true;
          if (props.selectType === "single") {
            const date = checkedDate.value[0];
            checkedDate.value = [__spreadProps$2(__spreadValues$2({}, date), {
              year,
              month
            })];
          }
          showWeek();
        }, transitionDuration.value * 1e3);
      }
    };
    const getLastWeek = () => {
      const checked = lastWeek.value[selectedDayIndex.value];
      showWeek(checked);
      if (formatDisabledDate(checked))
        return;
      if (!props.scrollChangeDate)
        return;
      checkedDate.value = [checked];
    };
    const getNextWeek = () => {
      const checked = nextWeek.value[selectedDayIndex.value];
      showWeek(checked);
      if (formatDisabledDate(checked))
        return;
      if (!props.scrollChangeDate)
        return;
      checkedDate.value = [checked];
    };
    const getLastMonth = () => {
      translateIndex.value += 1;
      if (!isLastWeekInCurrentMonth.value) {
        currentYearMonth.value = {
          year: lastMonthYear.value,
          month: lastMonth.value
        };
      }
      calculateCalendarOfThreeMonth();
    };
    const getNextMonth = () => {
      translateIndex.value -= 1;
      if (!isNextWeekInCurrentMonth.value) {
        currentYearMonth.value = {
          year: nextMonthYear.value,
          month: nextMonth.value
        };
      }
      calculateCalendarOfThreeMonth();
    };
    const dealCheckedDate = (date) => {
      const {
        selectType,
        maxRange
      } = props;
      const {
        year,
        month,
        day
      } = date;
      const checked = checkedDate.value;
      if (selectType === "single") {
        checkedDate.value = [{
          year,
          month,
          day
        }];
      } else if (selectType === "multiple") {
        const existIndex = checked.findIndex((item) => compareDay(item, date) === 0);
        if (existIndex > -1) {
          checkedDate.value.splice(existIndex, 1);
        } else {
          if (maxRange && checked.length >= maxRange) {
            emit("overRange");
            return;
          }
          checkedDate.value = [...checked, date];
        }
      } else if (selectType === "range") {
        date = __spreadProps$2(__spreadValues$2({}, date), {
          type: "start"
        });
        if (!checked || !checked.length) {
          checkedDate.value = [date];
          return;
        }
        const [startDay, endDay] = getStartEndDay(checked);
        if (startDay && !endDay) {
          const compareToStart = compareDay(date, startDay);
          if (compareToStart === 1) {
            const dateArr = calcMiddleDay([checked[0], __spreadProps$2(__spreadValues$2({}, date), {
              type: "end"
            })]);
            if (maxRange && dateArr.length > maxRange) {
              emit("overRange");
              return;
            }
            checkedDate.value = dateArr;
          } else if (compareToStart === -1) {
            checkedDate.value = [date];
          } else if (props.allowSameDay) {
            date = __spreadProps$2(__spreadValues$2({}, date), {
              type: "start-end"
            });
            checkedDate.value = [date, date];
          }
        } else {
          checkedDate.value = [date];
        }
      }
    };
    const clickCalendarDay = (date) => {
      if (!date.day)
        return;
      if (formatDisabledDate(date))
        return;
      dealCheckedDate(date);
      if (date.month === lastMonth.value && date.year === lastMonthYear.value) {
        getLastMonth();
      }
      if (date.month === nextMonth.value && date.year === nextMonthYear.value) {
        getNextMonth();
      }
      if (isShowWeek.value) {
        showWeek();
      }
      emit("click", date);
    };
    const isToday = (date) => yearOfToday.value === date.year && monthOfToday.value === date.month && dayOfToday.value === date.day;
    const isCheckedDay = (date) => {
      if (formatDisabledDate(date))
        return false;
      const {
        year,
        month,
        day
      } = date;
      return checkedDate.value.some((item) => item.year === year && item.month === month && item.day === day);
    };
    const isDisabledHorizontalScroll = (direc) => {
      const minDate = getMinDate(props.minDate);
      const maxDate = getMaxDate(props.maxDate);
      if (isShowWeek.value) {
        const lastWeekLastedDay = new Date(`${lastWeek.value[6].year}/${lastWeek.value[6].month + 1}/${lastWeek.value[6].day}`).getTime();
        const nextWeekFirstDay = new Date(`${nextWeek.value[0].year}/${nextWeek.value[0].month + 1}/${nextWeek.value[0].day}`).getTime();
        if (direc === "left" && maxDate)
          return nextWeekFirstDay >= maxDate;
        if (direc === "right" && minDate)
          return lastWeekLastedDay <= minDate;
      } else {
        const lastMonthLastedDay = new Date(`${lastMonthYear.value}/${lastMonth.value + 1}/${daysOfMonth(lastMonthYear.value)[lastMonth.value]}`).getTime();
        const nextMonthFirstDay = new Date(`${nextMonthYear.value}/${nextMonth.value + 1}/1`).getTime();
        if (direc === "left" && maxDate)
          return nextMonthFirstDay >= maxDate;
        if (direc === "right" && minDate)
          return lastMonthLastedDay <= minDate;
      }
      return false;
    };
    const isCanScroll = (dire) => {
      const scrollObj = {
        up: [true, "up", "vertical"],
        down: [true, "down", "vertical"],
        left: [true, "left", "horizontal"],
        right: [true, "right", "horizontal"]
      };
      const checkedScrollArr = scrollObj[dire];
      return !checkedScrollArr.some((item) => item === props.disabledScroll);
    };
    const setDisabledScrollDirection = () => {
      touch.value.x < 0 && !isCanScroll("left") && (touch.value.x = 0);
      touch.value.x > 0 && !isCanScroll("right") && (touch.value.x = 0);
      touch.value.y < 0 && !isCanScroll("up") && (touch.value.y = 0);
      touch.value.y > 0 && !isCanScroll("down") && (touch.value.y = 0);
    };
    const changeWeekView = ({
      isNext
    }) => {
      setTimeout(() => {
        isTouching.value = true;
        isNext ? getNextWeek() : getLastWeek();
      }, transitionDuration.value * 1e3);
    };
    const touchStart = (event) => {
      emit("touchstart", event);
      touchStartPositionX.value = event.touches[0].clientX;
      touchStartPositionY.value = event.touches[0].clientY;
      touch.value = {
        x: 0,
        y: 0
      };
      isTouching.value = true;
    };
    const touchMove = (event) => {
      emit("touchmove", event);
      if (!props.disabledWeekView) {
        event.stopPropagation();
        if (event.cancelable)
          event.preventDefault();
      }
      const moveX = event.touches[0].clientX - touchStartPositionX.value;
      const moveY = event.touches[0].clientY - touchStartPositionY.value;
      if (Math.abs(moveX) > Math.abs(moveY)) {
        if (isDisabledHorizontalScroll(moveX < 0 ? "left" : "right"))
          return;
        touch.value = {
          x: moveX / useRect(calendarRef).width,
          y: 0
        };
      } else {
        if (props.disabledWeekView)
          return;
        touch.value = {
          x: 0,
          y: moveY / useRect(calendarRef).height
        };
      }
      setDisabledScrollDirection();
    };
    const touchEnd = (e) => {
      emit("touchend", e);
      isTouching.value = false;
      if (Math.abs(touch.value.x) > Math.abs(touch.value.y) && Math.abs(touch.value.x) > 0.2) {
        if (touch.value.x > 0) {
          emit("slidechange", "right");
          getLastMonth();
          if (isShowWeek.value) {
            changeWeekView({
              isNext: false
            });
          }
        } else if (touch.value.x < 0) {
          emit("slidechange", "left");
          getNextMonth();
          if (isShowWeek.value) {
            changeWeekView({
              isNext: true
            });
          }
        }
      }
      if (Math.abs(touch.value.y) > Math.abs(touch.value.x) && Math.abs(touch.value.y * useRect(calendarRef).height) > 50) {
        if (touch.value.y > 0 && isShowWeek.value) {
          emit("slidechange", "down");
          showMonth();
        } else if (touch.value.y < 0 && !isShowWeek.value) {
          emit("slidechange", "up");
          showWeek();
        }
      } else {
        touch.value = {
          x: 0,
          y: 0
        };
      }
    };
    const markDateColor = (date, type) => {
      const dateString = `${date.year}/${fillNumber(date.month + 1)}/${fillNumber(date.day)}`;
      const markDateTypeString = markDateTypeObj.value[dateString] || "";
      if (markDateTypeString.indexOf(type) === -1)
        return;
      return markDateColorObj.value[dateString];
    };
    const dateFormat = (dateArr) => {
      dateArr.forEach((date, index) => {
        dateArr[index] = formatDate(date, "YY/MM/DD");
      });
      return dateArr;
    };
    useMountedOrActivated(init);
    watch(() => props.markDate, (val) => {
      const objArr = [];
      val.forEach((item) => {
        const obj = {
          date: [],
          color: "#1c71fb",
          type: props.markType
        };
        if (typeof item === "string" || typeof item === "number") {
          obj.date = [item];
        } else {
          obj.color = item.color || "#1c71fb";
          obj.type = item.type || props.markType;
          obj.date = dateFormat(item.date || []);
        }
        objArr.push(obj);
      });
      markDateColorObj.value = {};
      markDateTypeObj.value = {};
      objArr.forEach((item) => {
        item.date.forEach((date) => {
          markDateColorObj.value[date] = item.color;
          markDateTypeObj.value[date] = item.type;
        });
      });
    }, {
      deep: true,
      immediate: true
    });
    watch(weekStartIndex, () => {
      calculateCalendarOfThreeMonth();
    });
    watch(() => props.defaultDate, (val) => {
      if (props.selectType === "single" && val instanceof Date) {
        const year = val.getFullYear();
        const month = val.getMonth();
        currentYearMonth.value = {
          year,
          month
        };
        checkedDate.value = [transDateToYearMonthDay(val)];
      } else if (Array.isArray(val)) {
        const checked = val.map((item) => transDateToYearMonthDay(item));
        if (props.selectType === "range") {
          checkedDate.value = calcMiddleDay([__spreadProps$2(__spreadValues$2({}, checked[0]), {
            type: "start"
          }), __spreadProps$2(__spreadValues$2({}, checked[1]), {
            type: "end"
          })]);
        } else {
          checkedDate.value = checked;
        }
      }
      calculateCalendarOfThreeMonth();
      if (isShowWeek.value) {
        showWeek();
      }
    }, {
      immediate: true
    });
    watch(checkedDate, (val) => {
      emit("change", val);
    }, {
      deep: true,
      immediate: true
    });
    watch(() => props.show, (val) => {
      if (val) {
        calculateCalendarOfThreeMonth();
        init();
      }
    }, {
      immediate: true
    });
    watch(currentYearMonth, () => emit("yearMonthChange", currentYearMonth.value));
    watch(isShowWeek, (val) => {
      if (val) {
        nextTick(() => {
          showWeek();
        });
      } else {
        nextTick(() => {
          showMonth();
        });
      }
    });
    watch(() => props.defaultYearMonth, (val) => {
      if (val) {
        currentYearMonth.value = val;
      }
    }, {
      immediate: true
    });
    watch(calendarGroupHeight, (val) => {
      emit("height", val + calendarWeekTitleHeight.value);
    });
    useExpose({
      today,
      getLastMonth,
      getNextMonth,
      changeWeekView
    });
    const renderWeek = () => createVNode("div", {
      "class": "calendar_week",
      "ref": weekTitleRef
    }, [calendarWeek.value.map((item) => createVNode("div", {
      "class": "calendar_item",
      "key": item
    }, [createVNode("p", {
      "class": "calendar_day"
    }, [slots.week ? slots.week({
      week: item
    }) : item])]))]);
    const getRangeDayClassName = (date) => {
      if (props.selectType !== "range")
        return "";
      const currDate = checkedDate.value.find((item) => compareDay(item, date) === 0);
      if (!currDate)
        return "";
      const {
        type
      } = currDate;
      return type === "start" ? " calendar_range_checked calendar_range_start" : type === "middle" ? " calendar_range_checked calendar_range_middle" : type === "end" ? " calendar_range_checked calendar_range_end" : type === "start-end" ? " calendar_range_checked calendar_range_start-end" : "";
    };
    const renderDay = (date, i) => {
      let dayEle = isFirstDayOfMonth(date, i) ? stdin_default$6[props.lang].MONTH[date.month] : date.day === 0 ? "" : date.day;
      if (slots.day) {
        dayEle = slots.day({
          date,
          extendAttr: {
            isMarked: !!(markDateColor(date, "circle") || markDateColor(date, "dot")),
            isDisabledDate: formatDisabledDate(date),
            isToday: isToday(date),
            isChecked: isCheckedDay(date),
            isCurrentMonthDay: !isNotCurrentMonthDay(date, i),
            isFirstDayOfMonth: isFirstDayOfMonth(date, i)
          }
        });
      }
      return createVNode("div", {
        "class": `calendar_day ${isFirstDayOfMonth(date, i) ? props.firstDayOfMonthClassName || "calendar_first_today" : ""} ${isToday(date) ? props.todayClassName || "calendar_day_today" : ""} ${isCheckedDay(date) ? props.checkedDayClassName || "calendar_day_checked" : ""} ${isNotCurrentMonthDay(date, i) && props.showNotCurrentMonthDay ? props.notCurrentMonthDayClassName || "calendar_day_not" : ""} ${markDateColor(date, "circle") ? "calendar_mark_circle" : ""}`,
        "style": {
          "border-color": markDateColor(date, "circle")
        }
      }, [dayEle]);
    };
    const renderMonth = () => calendarOfMonthShow.value.map((item, i) => createVNode("li", {
      "class": "calendar_group_li",
      "key": i,
      "style": {
        transform: `translate3d(${(i - 1 + translateIndex.value + (isTouching.value ? touch.value.x : 0)) * 100}%, ${calendarY.value}px, 0)`,
        transitionDuration: `${isTouching.value ? 0 : transitionDuration.value}s`
      }
    }, [item.map((date, j) => createVNode("div", {
      "class": `calendar_item ${formatDisabledDate(date) ? props.disabledClassName || "calendar_item_disable" : ""}${getRangeDayClassName(date)}`,
      "ref": (el) => {
        calendarItemRef.length = 0;
        calendarItemRef.push(el);
      },
      "key": i + j,
      "onClick": () => clickCalendarDay(date)
    }, [renderDay(date, i), createVNode("div", {
      "style": {
        background: markDateColor(date, "dot")
      },
      "class": "calendar_dot"
    }, null)]))]));
    const renderCalendarDate = () => createVNode("div", {
      "class": "calendar_body",
      "style": {
        display: props.show ? "block" : "none"
      }
    }, [renderWeek(), createVNode("div", {
      "class": "calendar_group",
      "style": {
        height: `${calendarGroupHeight.value}px`
      },
      "ref": calendarRef,
      "onTouchstart": touchStart,
      "onTouchmove": touchMove,
      "onTouchend": touchEnd
    }, [createVNode("ul", {
      "style": {
        transform: `translate3d(${-translateIndex.value * 100}%, 0, 0)`
      }
    }, [renderMonth()])])]);
    return () => renderCalendarDate();
  }
});
const calendarTimeProps = {
  show: Boolean,
  defaultTime: makeDateProp(new Date()),
  disabledTime: {
    type: Function,
    default: () => false
  },
  minuteStep: makeNumberProp(1),
  calendarDate: {
    type: Object,
    default: () => ({})
  }
};
var stdin_default$4 = defineComponent({
  name: "CalendarTime",
  props: calendarTimeProps,
  emits: ["change"],
  setup(props, {
    emit
  }) {
    const timeContentRef = reactive([]);
    const timeItemRef = reactive([]);
    const checkedDate = ref({
      hours: new Date().getHours(),
      minutes: new Date().getMinutes()
    });
    const timeHeight = ref(0);
    const timeArray = ref([]);
    const timeStartY = ref(0);
    const timeStartUp = ref(0);
    const initTimeArray = () => {
      const hours = [];
      timeArray.value = [];
      for (let i = 0; i < 24; i++) {
        hours.push(i);
      }
      const minutes = [];
      for (let i = 0; i < 60; i++) {
        if (i % props.minuteStep === 0) {
          minutes.push(i);
        }
      }
      timeArray.value.push(hours, minutes);
      nextTick(() => {
        const checkHours = checkedDate.value.hours;
        const checkMinutes = checkedDate.value.minutes;
        timeHeight.value = useRect(timeItemRef[0]).height;
        const [timeContentFirst, timeContentSecond] = timeContentRef;
        const hoursUp = (2 - checkHours) * timeHeight.value;
        if (timeContentFirst) {
          timeContentFirst.style.transform = "translate3d(0px," + hoursUp + "px,0px)";
        }
        const minutesUp = (2 - checkMinutes / props.minuteStep) * timeHeight.value;
        if (timeContentSecond) {
          timeContentSecond.style.transform = "translate3d(0px," + minutesUp + "px,0px)";
        }
      });
    };
    const formatDisabledDate = (time, index) => {
      const hours = index === 0 ? time : checkedDate.value.hours;
      const minutes = index === 1 ? time : checkedDate.value.minutes;
      const dateStr = `${props.calendarDate.year}/${props.calendarDate.month + 1}/${props.calendarDate.day} ${hours}:${minutes}`;
      const fDate = new Date(dateStr);
      return props.disabledTime(fDate);
    };
    const timeTouchStart = (e) => {
      if (e.cancelable)
        e.preventDefault();
      timeStartY.value = e.changedTouches[0].pageY;
      const {
        transform
      } = e.currentTarget.style;
      if (transform) {
        timeStartUp.value = parseFloat(transform.split(" ")[1].split("px")[0]);
      }
    };
    const timeTouchEnd = (e, index) => {
      const {
        transform
      } = e.currentTarget.style;
      let endUp = timeStartUp.value;
      if (transform) {
        endUp = parseFloat(e.currentTarget.style.transform.split(" ")[1].split("px")[0]);
      }
      const distance = Math.abs(endUp - timeStartUp.value);
      const upCount = Math.floor(distance / timeHeight.value) || 1;
      const halfWinWith = timeHeight.value / 2;
      let up = timeStartUp.value;
      if (endUp <= timeStartUp.value) {
        if (distance <= halfWinWith) {
          up = timeStartUp.value;
        } else {
          up = timeStartUp.value - timeHeight.value * upCount;
          if (up < -(timeArray.value[index].length - 3) * timeHeight.value) {
            up = -(timeArray.value[index].length - 3) * timeHeight.value;
          }
        }
      } else if (distance <= halfWinWith) {
        up = timeStartUp.value;
      } else {
        up = timeStartUp.value + timeHeight.value * upCount;
        if (up > timeHeight.value * 2) {
          up = timeHeight.value * 2;
        }
      }
      if (index === 0) {
        const hour = 2 - Math.round(up / timeHeight.value);
        if (formatDisabledDate(hour, index)) {
          up = timeStartUp.value;
        } else {
          checkedDate.value.hours = hour;
        }
      } else {
        const minute = 2 - Math.round(up / timeHeight.value);
        if (formatDisabledDate(minute, index)) {
          up = timeStartUp.value;
        } else {
          checkedDate.value.minutes = minute * props.minuteStep;
        }
      }
      e.currentTarget.style.webkitTransition = "transform 300ms";
      e.currentTarget.style.transform = "translate3d(0px," + up + "px,0px)";
    };
    const timeTouchMove = (e, index) => {
      const moveEndY = e.changedTouches[0].pageY;
      const Y = moveEndY - timeStartY.value;
      e.currentTarget.style.transform = "translate3d(0px," + (Y + timeStartUp.value) + "px,0px)";
      if (checkPlatform() === "2") {
        timeTouchEnd(e, index);
        return false;
      }
    };
    const isBeSelectedTime = (time, index) => index === 0 && time === checkedDate.value.hours || index === 1 && time === checkedDate.value.minutes;
    watch(() => props.defaultTime, (val) => {
      if (!(val instanceof Date)) {
        throw new Error("The calendar component's defaultTime must be date type!");
      }
      checkedDate.value.hours = val.getHours();
      checkedDate.value.minutes = val.getMinutes();
    }, {
      immediate: true
    });
    watch(checkedDate, (val) => {
      emit("change", val);
    }, {
      deep: true,
      immediate: true
    });
    watch(() => props.show, (val) => {
      if (val) {
        setTimeout(() => {
          initTimeArray();
        }, 100);
      }
    }, {
      immediate: true
    });
    watch(() => props.minuteStep, (val) => {
      if (val <= 0 || val >= 60) {
        throw new Error(`The minutes-step can't be: ${val}!`);
      }
      if (60 % val !== 0) {
        throw new Error("The minutes-step must be divided by 60!");
      }
    }, {
      immediate: true
    });
    const renderTimeItem = (time, index) => time.map((item, j) => createVNode("div", {
      "ref": (ref2) => {
        timeItemRef.length = 0;
        timeItemRef.push(ref2);
      },
      "class": `time_item ${isBeSelectedTime(item, index) ? "time_item_show" : ""} ${formatDisabledDate(item, index) ? "time-disabled" : ""}`,
      "key": index + j
    }, [fillNumber(item)]));
    const renderCalendarTime = () => createVNode("div", {
      "class": "time_body",
      "style": {
        display: props.show ? "flex" : "none"
      }
    }, [createVNode("div", {
      "class": "time_group"
    }, [timeArray.value.map((item, index) => createVNode("div", {
      "class": "time_content",
      "ref": (ref2) => {
        timeContentRef.push(ref2);
      },
      "key": index,
      "onTouchstart": timeTouchStart,
      "onTouchmove": (e) => timeTouchMove(e, index),
      "onTouchend": (e) => timeTouchEnd(e, index)
    }, [renderTimeItem(item, index)]))])]);
    return () => renderCalendarTime();
  }
});
const calendarScrollContainerProps = {
  disabledScroll: {
    type: [Boolean, String],
    default: () => false
  },
  calendarData: makeArrayProp()
};
var stdin_default$3 = defineComponent({
  name: "CalendarScrollContainer",
  props: calendarScrollContainerProps,
  emits: ["slidechange", "touchstart", "touchmove", "touchend"],
  setup(props, {
    emit,
    slots
  }) {
    const containerRef = ref();
    const translateIndex = ref(0);
    const transitionDuration = ref(0.3);
    const touch = ref({
      x: 0,
      y: 0
    });
    const isTouching = ref(false);
    const touchStartPositionX = ref(0);
    const touchStartPositionY = ref(0);
    const calendarY = ref(0);
    const isCanScroll = (dire) => {
      const scrollObj = {
        up: [true, "up", "vertical"],
        down: [true, "down", "vertical"],
        left: [true, "left", "horizontal"],
        right: [true, "right", "horizontal"]
      };
      const checkedScrollArr = scrollObj[dire];
      return !checkedScrollArr.some((item) => item === props.disabledScroll);
    };
    const setDisabledScrollDirection = () => {
      touch.value.x < 0 && !isCanScroll("left") && (touch.value.x = 0);
      touch.value.x > 0 && !isCanScroll("right") && (touch.value.x = 0);
      touch.value.y < 0 && !isCanScroll("up") && (touch.value.y = 0);
      touch.value.y > 0 && !isCanScroll("down") && (touch.value.y = 0);
    };
    const touchStart = (event) => {
      emit("touchstart", event);
      touchStartPositionX.value = event.touches[0].clientX;
      touchStartPositionY.value = event.touches[0].clientY;
      touch.value = {
        x: 0,
        y: 0
      };
      isTouching.value = true;
    };
    const touchMove = (event) => {
      emit("touchmove", event);
      if (event.cancelable)
        event.preventDefault();
      event.stopPropagation();
      const moveX = event.touches[0].clientX - touchStartPositionX.value;
      const moveY = event.touches[0].clientY - touchStartPositionY.value;
      if (Math.abs(moveX) > Math.abs(moveY)) {
        touch.value = {
          x: moveX / useRect(containerRef).width,
          y: 0
        };
      } else {
        touch.value = {
          x: 0,
          y: moveY / useRect(containerRef).height
        };
      }
      setDisabledScrollDirection();
    };
    const touchEnd = (e) => {
      emit("touchend", e);
      isTouching.value = false;
      if (Math.abs(touch.value.x) > Math.abs(touch.value.y) && Math.abs(touch.value.x) > 0.2) {
        if (touch.value.x > 0) {
          emit("slidechange", "right");
          translateIndex.value += 1;
        } else if (touch.value.x < 0) {
          emit("slidechange", "left");
          translateIndex.value -= 1;
        }
      }
      if (Math.abs(touch.value.y) > Math.abs(touch.value.x) && Math.abs(touch.value.y * useRect(containerRef).height) > 50) {
        if (touch.value.y > 0) {
          emit("slidechange", "down");
        } else if (touch.value.y < 0) {
          emit("slidechange", "up");
        }
      } else {
        touch.value = {
          x: 0,
          y: 0
        };
      }
    };
    const renderDateItem = () => props.calendarData.map((item, i) => {
      var _a;
      return createVNode("li", {
        "class": "calendar_group_li",
        "key": i,
        "style": {
          transform: `translate3d(${(i - 1 + translateIndex.value + (isTouching.value ? touch.value.x : 0)) * 100}%, ${calendarY.value}px, 0)`,
          transitionDuration: `${isTouching.value ? 0 : transitionDuration.value}s`
        }
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots, item)]);
    });
    const renderContainer = () => createVNode("ul", {
      "class": "calendar_group_ul",
      "ref": "containerRef",
      "style": {
        transform: `translate3d(${-translateIndex.value * 100}%, 0, 0)`
      },
      "onTouchstart": touchStart,
      "onTouchmove": touchMove,
      "onTouchend": touchEnd
    }, [renderDateItem()]);
    return () => renderContainer();
  }
});
var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
const calendarYearMonthProps = {
  minDate: makeDateProp(null),
  maxDate: makeDateProp(null),
  disabledDate: {
    type: Function,
    default: () => false
  },
  checkedDayClassName: makeStringProp(""),
  notCurrentMonthDayClassName: makeStringProp(""),
  disabledClassName: makeStringProp(""),
  type: makeStringProp("date"),
  calendarContentHeight: makeNumberProp(0),
  disabledScroll: {
    type: [Boolean, String],
    default: () => false
  },
  currentYearMonth: {
    type: Object,
    default: () => ({})
  },
  lang: makeStringProp("CN")
};
var stdin_default$2 = defineComponent({
  name: "CalendarYearMonth",
  props: calendarYearMonthProps,
  emits: ["click", "slidechange", "touchstart", "touchmove", "touchend"],
  setup(props, {
    emit
  }) {
    const language = ref({});
    const yearRange = ref(10);
    const disabledScrollDirec = ref(false);
    const yearMonthShow = ref([]);
    const lang = props.lang.toUpperCase();
    language.value = stdin_default$6[lang];
    const itemHeight = computed(() => props.calendarContentHeight / 4);
    const initYear = (year) => {
      const yearArr = [];
      const currYear = `${year || props.currentYearMonth.year}`;
      const yearStart = parseInt(currYear.substring(0, 3) + "0", 10);
      for (let i = 0; i <= yearRange.value; i++) {
        yearArr.push(yearStart + i);
      }
      yearArr.unshift(yearStart - 1);
      return yearArr;
    };
    const initYearRange = (year) => {
      const yearRangeArr = [];
      const currYear = `${year || props.currentYearMonth.year}`;
      const yearStart = parseInt(currYear.substring(0, 2) + "00", 10);
      for (let i = 0; i <= yearRange.value; i++) {
        yearRangeArr.push({
          s: yearStart + i * 10,
          e: yearStart + i * 10 + 9
        });
      }
      yearRangeArr.unshift({
        s: yearStart - 10,
        e: yearStart - 1
      });
      return yearRangeArr;
    };
    const getThreeYearArr = (year = props.currentYearMonth.year) => {
      const yearStr = year + "";
      const yearStart = yearStr.substring(0, 3);
      const yearStartLast = parseInt(parseInt(yearStart, 10) - 1 + "0", 10);
      const yearStartCurr = parseInt(yearStart + "0", 10);
      const yearStartNext = parseInt(parseInt(yearStart, 10) + 1 + "0", 10);
      return [initYear(yearStartLast), initYear(yearStartCurr), initYear(yearStartNext)];
    };
    const getThreeYearRangeArr = (year = props.currentYearMonth.year) => {
      const yearStr = year + "";
      const yearStart = yearStr.substring(0, 2);
      const yearStartLast = parseInt(parseInt(yearStart, 10) - 1 + "00", 10);
      const yearStartCurr = parseInt(yearStart + "00", 10);
      const yearStartNext = parseInt(parseInt(yearStart, 10) + 1 + "00", 10);
      return [initYearRange(yearStartLast), initYearRange(yearStartCurr), initYearRange(yearStartNext)];
    };
    const getNextOpitonData = () => {
      if (props.type === "year") {
        const year = yearMonthShow.value[2][1];
        yearMonthShow.value = getThreeYearArr(year);
      } else if (props.type === "yearRange") {
        const value = yearMonthShow.value[2][1];
        const year = value.s;
        yearMonthShow.value = getThreeYearRangeArr(year);
      }
    };
    const getLastOptionData = () => {
      if (props.type === "year") {
        const year = yearMonthShow.value[0][1];
        yearMonthShow.value = getThreeYearArr(year);
      } else if (props.type === "yearRange") {
        const value = yearMonthShow.value[0][1];
        const year = value.s;
        yearMonthShow.value = getThreeYearRangeArr(year);
      }
    };
    const slideChange = (direc) => {
      if (direc === "left") {
        getNextOpitonData();
      } else if (direc === "right") {
        getLastOptionData();
      }
      emit("slidechange", direc);
    };
    const getRangeYear = (date) => {
      const yearStart = date.s;
      const yearEnd = date.e;
      const yearArr = [];
      for (let i = yearStart; i <= yearEnd; i++) {
        yearArr.push(i);
      }
      return yearArr;
    };
    const isDisabled = (date, index) => {
      let fDate = new Date();
      if (props.type === "month") {
        fDate = new Date(`${props.currentYearMonth.year}/${index + 1}/01`);
      } else if (props.type === "year") {
        fDate = new Date(`${date}/${props.currentYearMonth.month + 1}/01`);
      } else if (props.type === "yearRange") {
        const yearArr = getRangeYear(date);
        return yearArr.every((year) => {
          fDate = new Date(`${year}/${props.currentYearMonth.month + 1}/01`);
          return props.disabledDate(fDate) || !isDateInRange(fDate, props.minDate, props.maxDate);
        });
      }
      return props.disabledDate(fDate) || !isDateInRange(fDate, props.minDate, props.maxDate);
    };
    const dateClick = (date, index) => {
      if (!date)
        return;
      if (isDisabled(date, index))
        return;
      let checkedDate = __spreadValues$1({}, props.currentYearMonth);
      if (props.type === "month") {
        checkedDate = __spreadProps$1(__spreadValues$1({}, checkedDate), {
          month: index
        });
      }
      if (props.type === "year") {
        checkedDate = __spreadProps$1(__spreadValues$1({}, checkedDate), {
          year: date
        });
      }
      if (props.type === "yearRange") {
        const yearArr = getRangeYear(date);
        checkedDate = __spreadProps$1(__spreadValues$1({}, checkedDate), {
          year: yearArr.includes(checkedDate.year) ? checkedDate.year : date.s
        });
      }
      emit("click", checkedDate, props.type);
    };
    const isChecked = (date, index) => {
      if (props.type === "month") {
        return index === props.currentYearMonth.month;
      }
      if (props.type === "year") {
        return date === props.currentYearMonth.year;
      }
      if (props.type === "yearRange") {
        return date.s <= props.currentYearMonth.year && date.e >= props.currentYearMonth.year;
      }
    };
    const isNotCurrent = (index) => (index === 0 || index === 11) && (props.type === "year" || props.type === "yearRange");
    const touchStart = (event) => {
      emit("touchstart", event);
    };
    const touchMove = (event) => {
      emit("touchmove", event);
    };
    const touchEnd = (event) => {
      emit("touchend", event);
    };
    watch(() => props.type, (val) => {
      disabledScrollDirec.value = props.disabledScroll;
      if (val === "month" || val === "date") {
        disabledScrollDirec.value = true;
        yearMonthShow.value = [language.value.MONTH, language.value.MONTH, language.value.MONTH];
      } else if (val === "year") {
        yearMonthShow.value = getThreeYearArr();
      } else if (val === "yearRange") {
        yearMonthShow.value = getThreeYearRangeArr();
      }
    });
    const renderYearMonthItem = (arr) => arr.map((item, index) => createVNode("div", {
      "class": `year-body-item ${isDisabled(item, index) ? props.disabledClassName || "is_disabled" : ""}`,
      "style": {
        height: itemHeight.value + "px"
      },
      "key": index,
      "onClick": () => dateClick(item, index)
    }, [createVNode("p", {
      "class": `year-body-item-content ${isChecked(item, index) ? props.checkedDayClassName || "is_checked" : ""} ${isNotCurrent(index) ? props.notCurrentMonthDayClassName || "is_not_current" : ""}`,
      "style": {
        width: props.type === "yearRange" ? "92px" : "60px"
      }
    }, [props.type === "yearRange" ? `${item.s}-${item.e}` : props.type === "month" ? language.value.MONTH[index] : item])]));
    const renderYearMonth = () => createVNode("div", {
      "class": "year-body",
      "style": {
        height: itemHeight.value * 4 + "px",
        display: ["year", "yearRange", "month"].includes(props.type) ? "block" : "none"
      }
    }, [createVNode(stdin_default$3, {
      "calendarData": yearMonthShow.value,
      "disabledScroll": disabledScrollDirec.value,
      "onTouchstart": touchStart,
      "onTouchmove": touchMove,
      "onTouchend": touchEnd,
      "onSlidechange": slideChange
    }, (data) => renderYearMonthItem(data))]);
    return () => renderYearMonth();
  }
});
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const calendarProps = {
  themeColor: {
    type: Object,
    default: () => ({})
  },
  changeYearFast: Boolean,
  showArrow: Boolean,
  showWeekView: Boolean,
  visible: Boolean,
  disabledWeekView: Boolean,
  showAction: truthProp,
  pickerType: makeStringProp("datetime"),
  selectType: makeStringProp("single"),
  defaultYearMonth: {
    type: Object,
    default: {}
  },
  allowSameDay: Boolean,
  showTodayButton: truthProp,
  defaultDatetime: [Date, Array],
  minDate: makeDateProp(null),
  maxDate: makeDateProp(null),
  maxRange: makeNumberProp(0),
  format: makeStringProp(""),
  model: makeStringProp("inline"),
  markType: makeStringProp("dot"),
  markDate: makeArrayProp(),
  disabledDate: {
    type: Function,
    default: () => false
  },
  disabledTime: {
    type: Function,
    default: () => false
  },
  lang: makeStringProp("CN"),
  scrollChangeDate: truthProp,
  minuteStep: makeNumberProp(1),
  weekStart: makeStringProp("Sunday"),
  disabledScroll: {
    type: [Boolean, String],
    default: () => false
  },
  showNotCurrentMonthDay: truthProp,
  firstDayOfMonthClassName: makeStringProp(""),
  todayClassName: makeStringProp(""),
  checkedDayClassName: makeStringProp(""),
  notCurrentMonthDayClassName: makeStringProp(""),
  disabledClassName: makeStringProp("")
};
var stdin_default$1 = defineComponent({
  name: "VueHashCalendar",
  props: calendarProps,
  emits: ["update:visible", "update:showWeekView", "calendarTypeChange", "click", "confirm", "change", "overRange", "slidechange", "touchstart", "touchmove", "touchend"],
  setup(props, {
    emit,
    slots
  }) {
    const calendarRef = ref();
    const isShowCalendar = ref(true);
    const isShowWeek = ref(props.showWeekView);
    const calendarBodyHeight = ref(0);
    const firstTimes = ref(true);
    const currentYearMonth = ref({
      year: new Date().getFullYear(),
      month: new Date().getMonth()
    });
    const limitDateRange = (date, minDate = props.minDate, maxDate = props.maxDate) => {
      if (minDate && compareDay(transDateToYearMonthDay(date), transDateToYearMonthDay(minDate)) === -1) {
        return minDate;
      }
      if (maxDate && compareDay(transDateToYearMonthDay(date), transDateToYearMonthDay(maxDate)) === 1) {
        return maxDate;
      }
      return date;
    };
    const getInitialDateTime = (defaultDatetime = props.defaultDatetime) => {
      const {
        selectType,
        minDate,
        maxDate,
        allowSameDay
      } = props;
      if (defaultDatetime === null)
        return defaultDatetime;
      const nowDate = getToday();
      const nowDatetime = new Date();
      if (selectType === "range") {
        if (!Array.isArray(defaultDatetime)) {
          defaultDatetime = [];
        }
        const start = limitDateRange(defaultDatetime[0] || nowDate, minDate, allowSameDay ? maxDate : getPrevDay(transDateToYearMonthDay(maxDate)));
        const end = limitDateRange(defaultDatetime[1] || nowDate, allowSameDay ? minDate : getNextDay(transDateToYearMonthDay(minDate)));
        return [start, end];
      }
      if (selectType === "multiple") {
        if (Array.isArray(defaultDatetime)) {
          return defaultDatetime.map((date) => limitDateRange(date));
        }
        return [limitDateRange(nowDate)];
      }
      if (!defaultDatetime || Array.isArray(defaultDatetime)) {
        defaultDatetime = nowDatetime;
      }
      return limitDateRange(defaultDatetime);
    };
    const currDateTime = ref(getInitialDateTime());
    const checkedDate = ref([transDateToHourMinute(new Date())]);
    const yearMonthType = ref("date");
    const isShowDatetimePicker = computed({
      get() {
        return props.model === "inline" ? true : props.visible;
      },
      set(val) {
        emit("update:visible", val);
      }
    });
    const isShowArrowImg = computed(() => props.showArrow && props.model === "inline");
    const calendarContentHeight = computed(() => {
      if (props.pickerType === "time") {
        return 245;
      }
      return calendarBodyHeight.value;
    });
    const slideChange = (direction) => {
      emit("slidechange", direction);
    };
    const toggleWeek = () => {
      isShowWeek.value = !isShowWeek.value;
      if (isShowWeek.value)
        slideChange("up");
      else
        slideChange("down");
    };
    const today = () => {
      var _a;
      if (props.disabledDate(new Date()))
        return;
      (_a = calendarRef.value) == null ? void 0 : _a.today();
    };
    const reset = (date = getInitialDateTime()) => {
      currDateTime.value = date;
    };
    const lastMonth = () => {
      var _a;
      (_a = calendarRef.value) == null ? void 0 : _a.getLastMonth();
    };
    const nextMonth = () => {
      var _a;
      (_a = calendarRef.value) == null ? void 0 : _a.getNextMonth();
    };
    const lastWeek = () => {
      var _a, _b;
      (_a = calendarRef.value) == null ? void 0 : _a.getLastMonth();
      (_b = calendarRef.value) == null ? void 0 : _b.changeWeekView({
        isNext: false
      });
    };
    const nextWeek = () => {
      var _a, _b;
      (_a = calendarRef.value) == null ? void 0 : _a.getNextMonth();
      (_b = calendarRef.value) == null ? void 0 : _b.changeWeekView({
        isNext: true
      });
    };
    const dateChange = (date) => {
      if (props.selectType === "single") {
        checkedDate.value = [__spreadValues(__spreadValues({}, checkedDate.value[0]), date[0])];
      } else {
        checkedDate.value = date;
      }
    };
    const dateClick = (date) => {
      if (!date.day)
        return;
      let fDate;
      if (props.selectType === "single") {
        const checked = checkedDate.value[0];
        date.minutes = checked.minutes;
        date.hours = checked.hours;
        fDate = transHourMinuteToDate(date);
      } else {
        fDate = transYearMontDayToDate(date);
      }
      currDateTime.value = new Date(fDate);
      if (props.format) {
        fDate = formatDate(fDate, props.format, props.lang);
      }
      emit("click", fDate);
    };
    const yearMonthClick = (date, type) => {
      if (type) {
        switch (type) {
          case "yearRange":
            yearMonthType.value = "year";
            break;
          case "year":
            yearMonthType.value = "month";
            break;
          case "month":
            yearMonthType.value = "date";
            break;
        }
        emit("calendarTypeChange", yearMonthType.value);
      }
      currentYearMonth.value = {
        year: date.year,
        month: date.month
      };
      dateClick(date);
      if (props.selectType === "single") {
        const {
          day,
          hours,
          minutes
        } = checkedDate.value[0];
        let emitDate = transHourMinuteToDate(__spreadProps(__spreadValues({}, currentYearMonth.value), {
          day,
          hours,
          minutes
        }));
        if (props.format) {
          emitDate = formatDate(emitDate, props.format, props.lang);
        }
        emit("change", emitDate);
      }
    };
    const timeChange = (date) => {
      const {
        minutes,
        hours
      } = date;
      const checked = checkedDate.value[0];
      checkedDate.value = [__spreadProps(__spreadValues({}, checked), {
        minutes,
        hours
      })];
    };
    const close = () => {
      isShowDatetimePicker.value = false;
    };
    const makeEmitDate = () => {
      const dateArr = checkedDate.value.map((item) => {
        let date = transYearMontDayToDate(item);
        if (props.selectType === "single") {
          date = transHourMinuteToDate(item);
        }
        if (props.format) {
          return formatDate(date, props.format, props.lang);
        }
        return date;
      });
      if (props.selectType === "single") {
        return dateArr[0];
      }
      return dateArr;
    };
    const confirm = () => {
      emit("confirm", makeEmitDate());
      if (props.model === "dialog") {
        close();
      }
    };
    const formatDatetime = (time, format) => formatDate(time, format, props.lang);
    const showYearMonthPicker = () => {
      if (!props.changeYearFast)
        return;
      if (yearMonthType.value === "date") {
        yearMonthType.value = "month";
      } else if (yearMonthType.value === "month") {
        yearMonthType.value = "year";
      } else if (yearMonthType.value === "year") {
        yearMonthType.value = "yearRange";
      } else {
        yearMonthType.value = "date";
      }
      emit("calendarTypeChange", yearMonthType.value);
    };
    const showCalendar = () => {
      if (isShowCalendar.value) {
        showYearMonthPicker();
      } else {
        emit("calendarTypeChange", "date");
      }
      isShowCalendar.value = true;
    };
    const showTime = () => {
      isShowCalendar.value = false;
      emit("calendarTypeChange", "time");
      yearMonthType.value = "date";
    };
    const heightChange = (height) => {
      if (!firstTimes.value && props.model === "dialog")
        return;
      calendarBodyHeight.value = height;
      firstTimes.value = false;
    };
    const getThemeColor = () => {
      const cssVar = {};
      if (props.themeColor) {
        const themeColorKeys = Object.keys(props.themeColor || {});
        if (themeColorKeys.length) {
          themeColorKeys.forEach((k) => {
            cssVar[`--hash-calendar-${k}`] = props.themeColor[k];
          });
        }
      }
      return cssVar;
    };
    const touchStart = (event) => {
      emit("touchstart", event);
    };
    const touchMove = (event) => {
      emit("touchmove", event);
    };
    const touchEnd = (event) => {
      emit("touchend", event);
    };
    watch(checkedDate, () => {
      const emitDate = makeEmitDate();
      if (props.selectType === "range" && Array.isArray(emitDate) && emitDate.length === 1) {
        return;
      }
      emit("change", emitDate);
    }, {
      deep: true
    });
    watch(() => props.showWeekView, (val) => {
      isShowWeek.value = val;
    });
    watch(() => [props.selectType, props.minDate, props.maxDate], () => {
      if (props.selectType === "single") {
        reset(getInitialDateTime());
      } else {
        reset(getInitialDateTime(currDateTime.value));
      }
    });
    useExpose({
      today,
      reset,
      lastMonth,
      nextMonth,
      lastWeek,
      nextWeek
    });
    const init = () => {
      const date = currDateTime.value;
      if (!date) {
        checkedDate.value = [];
      } else if (date instanceof Date) {
        currentYearMonth.value = {
          year: date.getFullYear(),
          month: date.getMonth()
        };
        checkedDate.value = [transDateToHourMinute(date)];
      } else if (Array.isArray(date)) {
        if (props.selectType === "range") {
          const dateArr = calcMiddleDay([__spreadProps(__spreadValues({}, transDateToHourMinute(date[0])), {
            type: "start"
          }), __spreadProps(__spreadValues({}, transDateToHourMinute(date[1])), {
            type: "end"
          })]);
          checkedDate.value = dateArr.map((item) => transDateToHourMinute(transYearMontDayToDate(item)));
        } else {
          checkedDate.value = date.map((item) => transDateToHourMinute(item));
        }
      }
      if (props.pickerType === "time") {
        showTime();
      } else {
        isShowCalendar.value = true;
      }
    };
    useMountedOrActivated(init);
    const renderTodayButton = () => {
      let todayEle = stdin_default$6[props.lang].TODAY;
      if (slots.today) {
        todayEle = slots.today();
      }
      if (props.showTodayButton) {
        return createVNode("div", {
          "class": `calendar_confirm ${props.disabledDate(new Date()) ? "today_disable" : ""}`,
          "onClick": today
        }, [todayEle]);
      }
    };
    const renderConfirmButton = () => {
      let confirmEle = stdin_default$6[props.lang].CONFIRM;
      if (slots.confirm) {
        confirmEle = slots.confirm();
      }
      if (props.model === "dialog") {
        return createVNode("div", {
          "class": "calendar_confirm",
          "onClick": confirm
        }, [confirmEle]);
      }
    };
    const renderAction = () => {
      let timeText = "";
      const {
        year,
        month
      } = currentYearMonth.value;
      let dateText = formatDatetime(`${year}/${month + 1}`, stdin_default$6[props.lang].DEFAULT_YEAR_MONTH_FORMAT);
      if (props.selectType === "single") {
        const {
          day,
          hours,
          minutes
        } = checkedDate.value[0];
        timeText = formatDatetime(`${year}/${month + 1}/${day} ${fillNumber(hours)}:${fillNumber(minutes)}`, stdin_default$6[props.lang].DEFAULT_TIME_FORMAT);
        dateText = formatDatetime(`${year}/${month + 1}/${day}`, stdin_default$6[props.lang].DEFAULT_DATE_FORMAT);
      }
      if (props.showAction) {
        return createVNode("div", {
          "class": "calendar_title",
          "onClick": (e) => {
            if (e.cancelable)
              e.preventDefault();
            e.stopPropagation();
          },
          "style": {
            bottom: props.model === "dialog" ? `${calendarContentHeight.value}px` : "unset"
          }
        }, [slots.action ? slots.action() : createVNode(Fragment, null, [createVNode("div", {
          "class": "calendar_title_date"
        }, [props.pickerType !== "time" ? createVNode("span", {
          "class": `calendar_title_date_year ${isShowCalendar.value ? "calendar_title_date_active" : ""}`,
          "onClick": showCalendar
        }, [dateText]) : null, props.pickerType !== "date" && props.selectType === "single" ? createVNode("span", {
          "class": `calendar_title_date_time ${!isShowCalendar.value ? "calendar_title_date_active" : ""}`,
          "onClick": showTime
        }, [timeText]) : null]), renderTodayButton(), renderConfirmButton()])]);
      }
      return null;
    };
    const updateShowWeekView = (val) => {
      if (isShowWeek.value === val)
        return;
      if (val) {
        emit("calendarTypeChange", "week");
      } else {
        emit("calendarTypeChange", "date");
      }
      isShowWeek.value = val;
    };
    const yearMonthChange = (yearMonth) => {
      currentYearMonth.value = yearMonth;
    };
    const renderCalendar = () => createVNode(stdin_default$5, mergeProps({
      "ref": calendarRef,
      "show": isShowCalendar.value,
      "onHeight": heightChange,
      "defaultDate": currDateTime.value,
      "onTouchstart": touchStart,
      "onTouchmove": touchMove,
      "onTouchend": touchEnd,
      "onSlidechange": slideChange,
      "onYearMonthChange": yearMonthChange,
      "onChange": dateChange,
      "onOverRange": () => emit("overRange"),
      "onClick": dateClick,
      "showWeekView": isShowWeek.value,
      "onUpdate:showWeekView": updateShowWeekView
    }, pick(props, ["minDate", "maxDate", "maxRange", "disabledWeekView", "markType", "selectType", "allowSameDay", "defaultYearMonth", "markDate", "disabledDate", "lang", "weekStart", "disabledScroll", "scrollChangeDate", "showNotCurrentMonthDay", "firstDayOfMonthClassName", "todayClassName", "checkedDayClassName", "notCurrentMonthDayClassName", "disabledClassName"])), pick(slots, ["week", "day"]));
    const renderTimePicker = () => {
      if (props.pickerType === "datetime" || props.pickerType === "time") {
        return createVNode(stdin_default$4, mergeProps({
          "show": !isShowCalendar.value,
          "defaultTime": currDateTime.value,
          "calendarDate": checkedDate.value[0],
          "onChange": timeChange
        }, pick(props, ["minuteStep", "disabledTime"])), null);
      }
    };
    const renderYearMonthPicker = () => createVNode(stdin_default$2, mergeProps({
      "calendarContentHeight": calendarContentHeight.value,
      "currentYearMonth": currentYearMonth.value,
      "type": yearMonthType.value,
      "onTouchstart": touchStart,
      "onTouchmove": touchMove,
      "onTouchend": touchEnd,
      "onSlidechange": slideChange,
      "onClick": yearMonthClick
    }, pick(props, ["minDate", "maxDate", "disabledDate", "lang", "disabledScroll", "checkedDayClassName", "notCurrentMonthDayClassName", "disabledClassName"])), null);
    const renderCtrlImg = () => {
      let confirmEle = createVNode("img", {
        "src": isShowWeek.value ? ARROW_DOWN_IMG : ARROW_UP_IMG
      }, null);
      if (slots.arrow) {
        confirmEle = slots.arrow({
          isShowWeek: isShowWeek.value
        });
      }
      if (isShowArrowImg.value) {
        return createVNode("div", {
          "class": "ctrl-img",
          "onClick": toggleWeek,
          "style": {
            "margin-top": props.model === "dialog" ? `${calendarContentHeight.value}px` : "unset"
          }
        }, [confirmEle]);
      }
    };
    const renderHashCalendar = () => {
      if (isShowDatetimePicker.value || props.model === "inline") {
        return createVNode("div", {
          "class": `hash-calendar ${props.model === "inline" ? "calendar_inline" : ""}`,
          "style": __spreadValues({}, getThemeColor()),
          "onClick": close
        }, [renderAction(), createVNode("div", {
          "class": "calendar_content",
          "style": {
            height: `${calendarContentHeight.value}px`
          },
          "onClick": (e) => {
            if (e.cancelable)
              e.preventDefault();
            e.stopImmediatePropagation();
          }
        }, [props.pickerType !== "time" ? renderCalendar() : "", props.selectType === "single" && renderTimePicker(), props.changeYearFast ? renderYearMonthPicker() : ""]), renderCtrlImg()]);
      }
    };
    return () => renderHashCalendar();
  }
});
const Calendar = withInstall(stdin_default$1);
var stdin_default = Calendar;
export {
  Calendar,
  calendarProps,
  stdin_default as default
};
