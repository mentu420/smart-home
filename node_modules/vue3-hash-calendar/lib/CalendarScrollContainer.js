var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var stdin_exports = {};
__export(stdin_exports, {
  calendarScrollContainerProps: () => calendarScrollContainerProps,
  default: () => stdin_default
});
module.exports = __toCommonJS(stdin_exports);
var import_vue = require("vue");
var import_vue2 = require("vue");
var import_hooks = require("./hooks");
var import_utils = require("./utils");
const calendarScrollContainerProps = {
  disabledScroll: {
    type: [Boolean, String],
    default: () => false
  },
  calendarData: (0, import_utils.makeArrayProp)()
};
var stdin_default = (0, import_vue2.defineComponent)({
  name: "CalendarScrollContainer",
  props: calendarScrollContainerProps,
  emits: ["slidechange", "touchstart", "touchmove", "touchend"],
  setup(props, {
    emit,
    slots
  }) {
    const containerRef = (0, import_vue2.ref)();
    const translateIndex = (0, import_vue2.ref)(0);
    const transitionDuration = (0, import_vue2.ref)(0.3);
    const touch = (0, import_vue2.ref)({
      x: 0,
      y: 0
    });
    const isTouching = (0, import_vue2.ref)(false);
    const touchStartPositionX = (0, import_vue2.ref)(0);
    const touchStartPositionY = (0, import_vue2.ref)(0);
    const calendarY = (0, import_vue2.ref)(0);
    const isCanScroll = (dire) => {
      const scrollObj = {
        up: [true, "up", "vertical"],
        down: [true, "down", "vertical"],
        left: [true, "left", "horizontal"],
        right: [true, "right", "horizontal"]
      };
      const checkedScrollArr = scrollObj[dire];
      return !checkedScrollArr.some((item) => item === props.disabledScroll);
    };
    const setDisabledScrollDirection = () => {
      touch.value.x < 0 && !isCanScroll("left") && (touch.value.x = 0);
      touch.value.x > 0 && !isCanScroll("right") && (touch.value.x = 0);
      touch.value.y < 0 && !isCanScroll("up") && (touch.value.y = 0);
      touch.value.y > 0 && !isCanScroll("down") && (touch.value.y = 0);
    };
    const touchStart = (event) => {
      emit("touchstart", event);
      touchStartPositionX.value = event.touches[0].clientX;
      touchStartPositionY.value = event.touches[0].clientY;
      touch.value = {
        x: 0,
        y: 0
      };
      isTouching.value = true;
    };
    const touchMove = (event) => {
      emit("touchmove", event);
      if (event.cancelable)
        event.preventDefault();
      event.stopPropagation();
      const moveX = event.touches[0].clientX - touchStartPositionX.value;
      const moveY = event.touches[0].clientY - touchStartPositionY.value;
      if (Math.abs(moveX) > Math.abs(moveY)) {
        touch.value = {
          x: moveX / (0, import_hooks.useRect)(containerRef).width,
          y: 0
        };
      } else {
        touch.value = {
          x: 0,
          y: moveY / (0, import_hooks.useRect)(containerRef).height
        };
      }
      setDisabledScrollDirection();
    };
    const touchEnd = (e) => {
      emit("touchend", e);
      isTouching.value = false;
      if (Math.abs(touch.value.x) > Math.abs(touch.value.y) && Math.abs(touch.value.x) > 0.2) {
        if (touch.value.x > 0) {
          emit("slidechange", "right");
          translateIndex.value += 1;
        } else if (touch.value.x < 0) {
          emit("slidechange", "left");
          translateIndex.value -= 1;
        }
      }
      if (Math.abs(touch.value.y) > Math.abs(touch.value.x) && Math.abs(touch.value.y * (0, import_hooks.useRect)(containerRef).height) > 50) {
        if (touch.value.y > 0) {
          emit("slidechange", "down");
        } else if (touch.value.y < 0) {
          emit("slidechange", "up");
        }
      } else {
        touch.value = {
          x: 0,
          y: 0
        };
      }
    };
    const renderDateItem = () => props.calendarData.map((item, i) => {
      var _a;
      return (0, import_vue.createVNode)("li", {
        "class": "calendar_group_li",
        "key": i,
        "style": {
          transform: `translate3d(${(i - 1 + translateIndex.value + (isTouching.value ? touch.value.x : 0)) * 100}%, ${calendarY.value}px, 0)`,
          transitionDuration: `${isTouching.value ? 0 : transitionDuration.value}s`
        }
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots, item)]);
    });
    const renderContainer = () => (0, import_vue.createVNode)("ul", {
      "class": "calendar_group_ul",
      "ref": "containerRef",
      "style": {
        transform: `translate3d(${-translateIndex.value * 100}%, 0, 0)`
      },
      "onTouchstart": touchStart,
      "onTouchmove": touchMove,
      "onTouchend": touchEnd
    }, [renderDateItem()]);
    return () => renderContainer();
  }
});
